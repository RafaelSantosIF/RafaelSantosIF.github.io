<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>"/>
    <title>Robot's Last Stand</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
            overflow: hidden;
            -webkit-user-select: none; /* Para navegadores baseados em Chrome, Safari e Opera */
            -moz-user-select: none;    /* Para Firefox */
            -ms-user-select: none;     /* Para Internet Explorer e Edge antigos */
            user-select: none; 
        }

        /* Estilo geral para as telas de menu */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 26, 0.95);
            color: white;
            display: none; /* Come√ßam escondidas */
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 200;
        }

        .menu-container {
            padding: 30px;
            border: 2px solid #3498db;
            border-radius: 10px;
            background: #2c3e50;
        }

        .menu-container h1, .menu-container h2 {
            margin-top: 0;
            color: #f1c40f;
        }

        .menu-container button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #3498db;
            border: none;
            color: white;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .menu-container button:hover {
            background: #2980b9;
        }

        /* Estilo para a tela de Game Over */
        #finalStats p {
            margin: 5px 0;
            font-size: 16px;
        }
        #finalStats h3 {
            margin-top: 20px;
            color: #e74c3c;
        }
        #playerNameInput {
            padding: 10px;
            width: 200px;
            text-align: center;
            font-size: 16px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        #gameOverNav {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        /* Estilo para o √≠cone de trof√©u */
        #trophyBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 40px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #trophyBtn:hover {
            transform: scale(1.1);
        }

        /* Estilo para a lista de recordes */
        #highScoresList {
            list-style-type: decimal;
            padding-left: 40px;
            text-align: left;
        }
        #highScoresList li {
            font-size: 18px;
            padding: 5px 0;
        }

        /* Estilo para o √≠cone de interroga√ß√£o */
        #helpBtn {
            position: absolute;
            bottom: 20px; /* Posicionado no canto inferior direito */
            right: 20px;
            font-size: 40px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #helpBtn:hover {
            transform: scale(1.1);
        }

        /* Modifica o .menu-container para a tela de 'Sobre' */
        .about-container {
            width: 80%;
            max-width: 800px;
            height: 80%;
            text-align: left;
            overflow-y: auto; /* Permite rolagem vertical */
            padding: 20px 40px; /* Ajusta o espa√ßamento */
        }
        /* Estilos para os t√≠tulos dentro da wiki */
        .about-container h3 {
            color: #f1c40f;
            margin-top: 30px;
            border-bottom: 1px solid #3498db;
            padding-bottom: 5px;
        }
        /* Estilo para a lista na wiki */
        .about-container ul {
            list-style-type: none;
            padding-left: 0;
        }
        .about-container li {
            margin-bottom: 10px;
        }
        .about-container strong {
            color: #e74c3c;
        }

        #gameCanvas {
            position: relative;
            width: 1024px;
            height: 600px;
            background: linear-gradient(to bottom, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            border: 2px solid #333;
            overflow: hidden;
            cursor: cell;
        }

        .player {
            position: absolute;
            width: 20px;
            height: 30px;
            background: #e74c3c;
            border-radius: 3px;
            z-index: 10;
            transition: none;
        }

        .player::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 5px;
            width: 10px;
            height: 8px;
            background: #f39c12;
            border-radius: 50%;
        }

        .player::after {
            content: '';
            position: absolute;
            top: 15px;
            left: 2px;
            width: 16px;
            height: 2px;
            background: #34495e;
            border-radius: 1px;
        }

        /* Estilos que s√£o ativados quando o jogador se torna um MECHA */
        .player.mecha-active {
            width: 40px; /* Mais largo */
            height: 50px; /* Mais alto */
            background: #c0392b; /* Um vermelho mais intenso */
            border: 2px solid #2c3e50;
            border-radius: 5px 5px 0 0;
        }

        /* O ::before ser√° o canh√£o esquerdo */
        .player.mecha-active::before {
            content: '';
            position: absolute;
            top: 10px;
            left: -12px; /* Posicionado √† esquerda do corpo */
            width: 10px;
            height: 25px;
            background: #7f8c8d;
            border: 2px solid #34495e;
            border-radius: 3px;
        }

        /* O ::after ser√° o canh√£o direito */
        .player.mecha-active::after {
            content: '';
            position: absolute;
            top: 10px;
            right: 12px; /* Posicionado √† direita do corpo */
            width: 10px;
            height: 25px;
            background: #7f8c8d;
            border: 2px solid #34495e;
            border-radius: 3px;
        }

        .block {
            position: absolute;
            background: #7f8c8d;
            border: 1px solid #95a5a6;
            box-shadow: inset 0 0 0 1px #bdc3c7;
        }

        .tower {
            position: absolute;
            background: #5d6d7e;
            border-radius: 5px 5px 0 0;
            border: 2px solid #85929e;
        }

        .tower::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 60%;
            height: 40%;
            background: #2c3e50;
            border-radius: 2px;
        }

        .enemy {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #e67e22;
            border-radius: 50% 50% 0 0;
            z-index: 8;
            border: 1px solid #d35400;
            transition: background-color 0.3s;
        }

        .enemy::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 6px;
            background: #c0392b;
            border-radius: 50%;
        }

        .enemy::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 6px;
            width: 4px;
            height: 6px;
            background: #8e44ad;
            border-radius: 0 0 50% 50%;
        }

        .enemy-projectile {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #e74c3c;
            border-radius: 50%;
            box-shadow: 0 0 3px #c0392b;
            z-index: 5;
        }

        /* Estilo do Vigia (o inimigo atual) */
        .enemy.vigia {
            background: #e67e22; /* Laranja */
            border-radius: 50% 50% 0 0;
        }

        /* Estilo do Ariete: retangular e blindado */
        .enemy.ariete {
            position: absolute;
            width: 40px;
            height: 20px;
            background: #9e9696; 
            border-radius: 10px 10px 2px 2px; 
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3); 
        }

        .enemy.ariete::before {
            content: '';
            position: absolute;
            left: -8px; 
            width: 8px;
            height: 16px;
            background: #c4bbba; 
            border-radius: 4px 4px 0 0;
        }

        /* Estilo da Unidade Inst√°vel: um cubo que pisca */
        .enemy.unidade-instavel {
            width: 18px;
            height: 18px;
            background: #c0392b; /* Vermelho perigo */
            border-radius: 3px;
            border: 2px solid #2c3e50;
        }
        .enemy.unidade-instavel.primed {
            animation: pulse-red 0.5s infinite;
        }
        @keyframes pulse-red {
            0% { background-color: #c0392b; }
            50% { background-color: #e74c3c; transform: scale(1.1); }
            100% { background-color: #c0392b; }
        }

        /* Estilo do Basti√£o: grande e imponente */
        .enemy.bastiao {
            position: absolute;
            width: 50px;
            height: 45px;
            background: #777; /* Cinza mais escuro para a base */
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            z-index: 1;
        }

        .enemy.bastiao::before {
            content: '';
            position: absolute;
            top: -10px;  
            width: 20px;
            height: 20px;
            background: #555; 
            border-radius: 50%;
        }

        .enemy.bastiao::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 12px;
            background: #eee; /* Abertura da arma */
            border-radius: 3px;
        }

        .enemy.bastiao.falling {
            border-radius: 0; /* Remove o arredondamento durante a queda */
        }

        .heavy-plasma { /* Proj√©til do Basti√£o */
            width: 10px;
            height: 10px;
            background: #e74c3c;
            border-radius: 3px;
            box-shadow: 0 0 8px #c0392b;
            z-index: 5;
            position: absolute;
        }

        /* Estilo do Ceifador: pequeno, angular e amea√ßador */
        .enemy.ceifador {
            position: absolute;
            width: 20px;
            height: 35px;
            background: #8a0adf; 
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1;
        }        

        .enemy.ceifador::after {
            content: '';
            position: absolute;
            top: 5px;
            width: 8px;
            height: 8px;
            background: #f1c40f; 
            border-radius: 50%;
        }

        /* Estilo da Mira Laser */
        .laser-sight {
            position: absolute;
            height: 1px; /* Linha fina */
            background: linear-gradient(90deg, rgba(255, 50, 50, 0), rgba(255, 50, 50, 1)); /* Gradiente para dar um efeito de brilho */
            z-index: 7;
            /* O truque para a rota√ß√£o funcionar corretamente a partir do ponto de origem */
            transform-origin: left center; 
            display: none; /* Come√ßa escondida */
        }

        /* Estilo do Proj√©til do Sniper */
        .sniper-shot {
            position: absolute;
            width: 15px;
            height: 3px;
            background: #e74c3c;
            border-radius: 2px;
            box-shadow: 0 0 8px red;
            z-index: 5;
        }

        /* Estilo para o Bombardeiro */
        .enemy.bombardeiro {
            width: 36px;
            height: 16px;
            background: #020b8a; /* Cinza escuro, cor militar */
            border: 2px solid #ffffff;
            border-radius: 4px;
        }
        /* Simula "asas" ou propulsores nas laterais */
        .enemy.bombardeiro::before, .enemy.bombardeiro::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 20px;
            background: #036dd6;
            top: -2px;
        }
        .enemy.bombardeiro::before {
            left: -10px;
            border-radius: 4px 0 0 4px;
        }
        .enemy.bombardeiro::after {
            right: -10px;
            border-radius: 0 4px 4px 0;
        }

        /* Estilo para a bomba que cai */
        .falling-bomb {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #f0a400;
            border: 2px solid #340049; 
            border-radius: 50%;
            z-index: 5;
        }

        /* Estilo para o Drone M√©dico */
        .enemy.drone-medico {
            width: 20px;
            height: 20px;
            background: #ecf0f1; /* Branco */
            border: 3px solid #2ecc71; /* Verde, cor de cura */
            border-radius: 50%;
        }
        /* A "cruz" do m√©dico no centro */
        .enemy.drone-medico::before {
            content: '';
            position: absolute;
            width: 4px;
            height: 12px;
            background: #27ae60;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 2px;
        }
        .enemy.drone-medico::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 4px;
            background: #27ae60;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 2px;
        }

        /* Estilo para o Feixe de Cura */
        .healing-beam {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(46, 204, 113, 0), rgba(46, 204, 113, 1));
            z-index: 7;
            transform-origin: left center;
            display: none; /* Come√ßa escondido */
        }

        /* Estilo para o Escudo concedido aos drones */
        .drone-shield {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 130%; /* Ligeiramente maior que o drone */
            height: 130%;
            background: rgba(46, 204, 113, 0.2); /* Bolha de energia verde */
            border: 1px solid #2ecc71;
            border-radius: 50%;
            z-index: 8;
        }

        .hp-bar, .exp-bar {
            position: relative;
            width: 200px;
            height: 20px;
            background: #2c3e50;
            border: 2px solid #34495e;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
        }

        .exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            transition: width 0.3s ease;
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 1;
        }

        .invincible {
            animation: blink 0.1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .cloud {
            position: absolute;
            background: #ecf0f1;
            border-radius: 20px;
            opacity: 0.6;
        }

        .cloud::before {
            content: '';
            position: absolute;
            background: #ecf0f1;
            border-radius: 50%;
        }

        .moon {
            position: absolute;
            width: 60px;
            height: 60px;
            background: #f4f4f4;
            border-radius: 50%;
            top: 50px;
            right: 200px;
            box-shadow: inset -10px -10px 0 #e8e8e8;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            z-index: 20;
        }

        .ui-bars {
            margin-bottom: 10px;
        }
       
        .energy-bar {
            position: relative;
            width: 200px;
            height: 20px;
            background: #2c3e50;
            border: 2px solid #34495e;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9); 
            transition: width 0.1s linear;
        }

        .projectile {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #f1c40f;
            border-radius: 50%;
            box-shadow: 0 0 4px #f39c12;
            z-index: 5;
        }

        /* ESTILOS PARA A TELA DE LEVEL UP E CARTAS */
        #levelUpScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: none; /* Come√ßa escondida */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: monospace;
            color: white;
        }

        #levelUpTitle {
            text-shadow: 2px 2px 4px #000000;
            margin-bottom: 30px;
        }

        #cardContainer {
            display: flex;
            gap: 20px;
        }

        .upgrade-card {
            width: 180px;
            height: 250px;
            background: #2c3e50;
            border: 4px solid #7f8c8d;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.7);
        }

        .card-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .card-rarity {
            font-size: 12px;
            font-style: italic;
            margin-bottom: 20px;
        }

        .card-description {
            font-size: 14px;
        }

        /* CORES DAS RARIDADES */
        .rarity-Comum { border-color: #95a5a6; } /* Cinza */
        .rarity-Incomum { border-color: #2ecc71; } /* Verde */
        .rarity-Raro { border-color: #3498db; } /* Azul */
        .rarity-√âpico { border-color: #9b59b6; } /* Roxo */
        .rarity-Lend√°rio { border-color: #f1c40f; } /* Dourado */


        /* Estilos para o rastreador de upgrades no canto da tela */
        #upgradeTracker {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 25;
            display: flex;
            flex-direction: row-reverse; /* Novas colunas aparecem √† esquerda */
            align-items: flex-end; /* Alinha as colunas pela base */
            gap: 8px; /* Espa√ßo entre as colunas */
        }

        .tracker-icon-container {
            width: 40px;
            height: 40px;
            background: rgba(44, 62, 80, 0.8);
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Para posicionar o n√∫mero de stacks */
        }

        .upgrade-column {
            display: flex;
            flex-direction: column-reverse; /* Empilha os √≠cones de baixo para cima */
            gap: 8px; /* Espa√ßo entre os √≠cones na mesma coluna */
        }

        .tracker-icon {
            font-size: 24px; /* Tamanho do emoji */
            filter: drop-shadow(0 0 2px black);
        }

        .tracker-stack-count {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: #e74c3c;
            color: white;
            font-weight: bold;
            font-size: 12px;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid white;
        }
        /* ESTILOS DO DRONE */
        .drone {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #3498db;
            border: 2px solid #ecf0f1;
            border-radius: 50%;
            z-index: 11;
            box-shadow: 0 0 8px #3498db, inset 0 0 4px white;
        }
        .drone-projectile {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3498db;
            border-radius: 50%;
            box-shadow: 0 0 4px #3498db;
            z-index: 5;
        }

        /* ESTILOS HP BAR INIMIGO */
        .enemy-hp-bar-container {
            position: absolute;
            top: -10px;
            width: 100%;
            height: 4px;
            background-color: #555;
            border-radius: 2px;
            display: none;
        }
        .enemy-hp-bar-fill {
            width: 100%;
            height: 100%;
            background-color: #c0392b;
            border-radius: 2px;
            transition: width 0.2s linear;
        }

        .megaprojectile {
            /* Torna o proj√©til maior */
            width: 10px;
            height: 10px;
            /* Muda a cor e o brilho para algo mais intenso */
            background: #ffde7d; /* Amarelo claro/branco */
            box-shadow: 0 0 12px #f39c12, 0 0 5px #ffde7d; /* Brilho maior e mais forte */
            border-radius: 4px; /* Um pouco mais quadrado para parecer mais "energizado" */
        }
        
        /* Estilo da Torreta Estacion√°ria */
        .turret {
            position: absolute;
            width: 24px;
            height: 20px;
            background: #7f8c8d; /* Cinza met√°lico, como as plataformas */
            border-top: 2px solid #bdc3c7;
            border-radius: 4px 4px 0 0;
            z-index: 9; /* Fica atr√°s do jogador mas na frente dos inimigos */
        }

        /* O "cano" da torreta que ir√° girar */
        .turret-barrel {
            position: absolute;
            width: 18px;
            height: 4px;
            background: #34495e;
            top: 6px;
            left: 3px;
            border-radius: 2px;
            transform-origin: 20% 50%; /* Ponto de rota√ß√£o (gira a partir da base) */
            transition: transform 0.1s linear;
        }

        /* Estilo do proj√©til da torreta */
        .turret-projectile {
            position: absolute;
            width: 5px;
            height: 5px;
            background: #2ecc71; /* Verde, para diferenciar */
            border-radius: 50%;
            box-shadow: 0 0 5px #27ae60;
            z-index: 5;
        }

        /* Estilo da Vespa: pequena, r√°pida e amarela/preta */
        .enemy.vespa {
            width: 12px;
            height: 12px;
            background: #f1c40f; /* Amarelo */
            border: 2px solid #2c3e50; /* Preto/Azul escuro */
            border-radius: 50% 30%; /* Forma ovalada/asim√©trica */
        }
        .enemy.vespa::before, .enemy.vespa::after {
            display: none; /* Remove decora√ß√µes padr√£o */
        }

        /* Estilo para o raio da Tempestade I√¥nica */
        .ionic-bolt {
            position: absolute;
            width: 8px; /* Raio fino mas vis√≠vel */
            height: 100%; /* Ocupa toda a altura do canvas */
            top: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0.5), #00e6e6, rgba(255,255,255,0.5));
            box-shadow: 0 0 10px #00e6e6, 0 0 15px white;
            z-index: 6; /* Fica na frente dos inimigos mas atr√°s do jogador */
            animation: flash-in-out 0.2s linear;
        }

        @keyframes flash-in-out {
            0%   { opacity: 0; }
            50%  { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Estilo para os proj√©teis de fragmenta√ß√£o */
        .fragment-projectile {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #95a5a6; /* Cinza met√°lico */
            transform: rotate(45deg); /* Faz o quadrado parecer um losango */
            z-index: 5;
        }

        /* Estilo para o inimigo infetado pelo v√≠rus */
        .enemy.corroded {
            /* Adiciona um brilho pulsante verde e doentio */
            box-shadow: 0 0 10px #2ecc71, 0 0 15px white;
            animation: pulse-green 1s infinite;
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 8px #27ae60, 0 0 12px #2ecc71; }
            50% { box-shadow: 0 0 14px #2ecc71, 0 0 20px white; }
            100% { box-shadow: 0 0 8px #27ae60, 0 0 12px #2ecc71; }
        }

        .energy-shield {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: rgba(52, 152, 219, 0.3);
            border: 2px solid rgba(52, 152, 219, 1);
            border-radius: 50%;
            z-index: 11;
            transition: opacity 0.3s, transform 0.3s;
        }

        .kinetic-rocket {
            position: absolute;
            width: 6px;
            height: 14px;
            background: #f39c12;
            border: 1px solid white;
            border-radius: 3px;
            z-index: 5;
        }

        /* Estilo para a Serra Circular Orbital */
        .orbital-saw {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #bdc3c7; /* Cor de metal */
            border: 3px dashed #7f8c8d; /* Borda tracejada para simular dentes */
            border-radius: 50%; /* Faz o elemento ser um c√≠rculo */
            z-index: 11; /* Fica na frente de quase tudo, exceto a UI */
            animation: spin 0.5s linear infinite; /* Anima√ß√£o de rota√ß√£o cont√≠nua */
        }

        /* Anima√ß√£o de rota√ß√£o */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        /* Estilo para a barra de vida do chefe */
        #bossHealthBarContainer {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            z-index: 150;
            text-align: center;
        }
        #bossName {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
        }
        .boss-bar {
            width: 100%;
            height: 25px;
        }

        /* Estilo para a Colmeia-M√£e */
        .enemy.colmeia-mae {
            width: 250px; /* Bem larga */
            height: 100px;
            background: #f806ec;
            border: 4px solid #8e44ad; /* Borda roxa de elite */
            border-radius: 10px 10px 40px 40px; /* Base arredondada */
            z-index: 1; /* Fica atr√°s de outros drones */
        }
        /* Canh√£o Central */
        .enemy.colmeia-mae::before {
            content: '';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 30px;
            background: #c0392b;
            border-radius: 5px;
        }
        /* Comporta de Drones */
        .enemy.colmeia-mae::after {
            content: '';
            position: absolute;
            bottom: -8px; /* Fica na parte de baixo */
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 10px;
            background: #f1c40f; /* Amarelo de alerta */
            border-radius: 3px;
        }

    </style>
</head>
<body>
    <div id="mainMenu" class="screen">
        <div class="menu-container">
            <h1>Robot's Last Stand</h1>
            <button id="startGameBtn">Iniciar Jogo</button>
            <button id="difficultyBtn">Sele√ß√£o de Dificuldade</button>
            <button id="settingsBtn">Configura√ß√µes</button>
        </div>
        <div id="trophyBtn" title="Recordes">üèÜ</div>
        <div id="helpBtn" title="Sobre o Jogo">‚ùì</div>
    </div>

    <div id="gameOverScreen" class="screen">
        <div class="menu-container">
            <h2>Fim de Jogo</h2>
            <div id="finalStats">
                <p>N√≠vel Alcan√ßado: <span id="levelStat"></span></p>
                <p>Tempo Sobrevivido: <span id="timeStat"></span></p>
                <p>Inimigos Abatidos: <span id="killsStat"></span></p>
                <h3>Pontua√ß√£o Final: <span id="scoreStat"></span></h3>
            </div>
            <div id="saveScoreSection">
                <input type="text" id="playerNameInput" placeholder="Digite seu nome (3 letras)" maxlength="3">
                <button id="saveScoreBtn">Salvar Recorde</button>
            </div>
            <div id="gameOverNav">
                <button id="playAgainBtn">Jogar Novamente</button>
                <button id="backToMenuBtn">Menu Principal</button>
            </div>
        </div>
    </div>

    <div id="highScoresScreen" class="screen">
        <div class="menu-container">
            <h2>Tabela de Recordes</h2>
            <ol id="highScoresList"></ol>
            <button id="backToMenuFromScoresBtn">Voltar</button>
        </div>
    </div>

    <div id="aboutScreen" class="screen">
        <div class="menu-container about-container">
            <div id="aboutContent"></div>
            
            <button id="backToMenuFromAboutBtn">Voltar</button>
        </div>
    </div>

    <div id="gameCanvas">
        <div id="ui">
            <div class="ui-bars">
                <div class="hp-bar">
                    <div class="hp-fill" id="hpFill"></div>
                    <div class="bar-text" id="hpText">HP: 100/100</div>
                </div>
                <div class="exp-bar">
                    <div class="exp-fill" id="expFill"></div>
                    <div class="bar-text" id="expText">Level 1 - EXP: 0/100</div>
                </div>
                <div class="energy-bar">
                    <div class="energy-fill" id="energyFill"></div>
                    <div class="bar-text" id="energyText">ENERGIA: 0/100</div>
                </div>
            </div>
            <div>Use A/D/W para mover e pular, MOUSE para atirar</div>
            <div id="gameStats">Inimigos Abatidos: 0</div>
            <div id="survivalTime">Tempo Sobrevivido: 00:00</div>
        </div>
        <div id="upgradeTracker"></div>
        <div class="moon"></div>
        <div id="gameObjectsContainer"></div>
        <div class="player" id="player"></div>
        <div id="playerDrone" class="drone" style="display: none;"></div>
        
        <div id="levelUpScreen" style="display: none;">
            <h2 id="levelUpTitle">Melhoria de N√≠vel! Escolha um M√≥dulo:</h2>
            <div id="cardContainer"></div>
        </div>
        <div id="bossHealthBarContainer" style="display: none;">
            <div id="bossName">Colmeia-M√£e</div>
            <div class="hp-bar boss-bar">
                <div class="hp-fill" id="bossHpFill"></div>
            </div>
        </div>
    </div>

    <script>
        class Game {
            constructor(audioCtx) {
                this.audioCtx = audioCtx;
                this.bossMusicInterval = null;
                this.canvas = document.getElementById('gameCanvas');
                this.gameObjectsContainer = document.getElementById('gameObjectsContainer');
                this.player = document.getElementById('player');
                this.collectedUpgrades = new Map();
                this.keys = {};
                this.mouse = { x: 0, y: 0, pressed: false };
                this.projectiles = [];
                this.enemyProjectiles = [];
                this.enemies = [];
                this.blocks = [];
                this.bombs = [];
                this.orbs = [];
                this.orbitalSaws = [];
                this.fallingBombs = [];
                this.gameState = 'survival'; // 'survival' ou 'boss_fight'
                this.boss = null;
                this.scrapChance = 0;                
                this.lastShot = 0;
                this.lastEnemySpawn = 0;
                this.gameTime = 0;
                this.enemiesKilled = 0;
                this.finalScore = 0;
                this.isPaused = false;
                this.isGameOver = false;
                this.dashEnabled = false;
                this.lastKeyPress = { KeyA: 0, KeyD: 0 };
                this.dashCooldown = 1500; 
                this.lastDashTime = 0;                
                this.shootCooldown = 500;
                this.enemySpawnRate = 2000;
                this.explosiveShotChance = 0;
                this.enemyHpBarsVisible = false;
                this.cryoChance = 0;
                this.vengeanceProtocolActive = false;
                this.phoenixProtocolCharges = 0;
                this.lifestealChance = 0;
                this.lifestealAmount = 1;
                this.corrosiveVirusChance = 0;
            
                // Dentro do constructor
                this.enemyCatalog = [                    
                    { type: 'Vigia', minTime: 0, weight: 12 },                    
                    { type: 'Ariete', minTime: 30000, weight: 6 },
                    { type: 'Vespa', minTime: 45000, weight: 8 },                            
                    { type: 'UnidadeInstavel', minTime: 60000, weight: 4 },
                    { type: 'Bombardeiro', minTime: 90000, weight: 3 },
                    { type: 'Ceifador', minTime: 120000, weight: 2 },
                    { type: 'DroneMedico', minTime: 160000, weight: 2 },                         
                    { type: 'Bastiao', minTime: 180000, weight: 1 },
                ];

                this.activePrimeUpgrade = null; // Guarda o nome do upgrade PRIME equipado
                this.primeEffects = { // Objeto para controlar o estado dos efeitos
                    isNitroActive: false,
                    isShieldActive: false,
                    isMegaPropulsionActive: false,
                    isMatrixActive: false,
                    bombardment: { active: false, lastBomb: 0, cooldown: 300 },
                };

                this.predatorFocus = {
                    active: false,
                    bonusDamage: 0,
                    timeStill: 0
                };

                this.turrets = [];
                this.turretProjectiles = [];                
                this.turretPositions = {
                    left: { x: 370, y: 550 }, 
                    right: { x: 624, y: 550 }
                };
                
                this.ionicStorm = {
                    active: false,
                    cooldown: 6000, // Um evento de tempestade a cada 6 segundos
                    lastStorm: 0,
                    numBolts: 2, 
                    damage: 30, // Dano alto por raio
                };

                this.fragmentationModule = {
                    active: false,
                    numFragments: 3, // Come√ßa com 3 fragmentos por morte
                    damage: 5,       // Dano de cada fragmento
                };
                this.fragmentProjectiles = [];

                this.energyShield = {
                    active: false,
                    ready: false,
                    cooldown: 8000, // 8 segundos para recarregar
                    lastHitTime: 0,
                    element: null,
                };

                this.kineticReactor = {
                    active: false,
                    distanceMeter: 0,
                    distanceThreshold: 600, // Dispara a cada 600 pixels percorridos
                    numRockets: 3,
                };
                this.rockets = [];

                this.playerState = {
                    x: 512,
                    y: 470,
                    vx: 0,
                    vy: 0,
                    onGround: false,
                    isDashing: false,
                    isMecha: false,
                    width: 20,
                    height: 30,
                    maxHp: 100,
                    hp: 100,
                    exp: 0,
                    expMultiplier: 1.0,
                    level: 1,
                    expToNext: 100,
                    invincible: false,
                    invincibleTime: 0,
                    baseProjectileDamage: 1,
                    projectileSize: 4,
                    hpRegen: 0,
                    extraProjectiles: 0,
                    damageReduction: 0,
                    energy: 0, 
                    maxEnergy: 100,
                    energyRegenRate: 0.05,
                    jumpsUsed: 0,
                    maxJumps: 1
                };

                this.lastRegenTime = 0;
                this.invincibilityDuration = 500;
                this.gravity = 0.8;
                this.jumpPower = -12;
                this.moveSpeed = 4;
                this.projectileSpeed = 8;
                
                // --- Estado do Drone ---
                this.droneElement = document.getElementById('playerDrone');
                this.droneProjectiles = [];
                this.droneState = {
                    active: false,
                    x: 0,
                    y: 0,
                    shootCooldown: 1000,
                    lastShot: 0,
                    target: null,
                };

                // --- Estado do Emissor de Pulsos ---
                this.pulseEmitter = {
                    active: false,
                    cooldown: 5000,
                    lastPulse: 0,
                    damage: 4,
                    radius: 120
                };

                this.staticCharge = {
                    active: false,
                    cooldown: 500, // Pulsa a cada 0.5 segundos
                    lastTick: 0,
                    damage: 1,
                    radius: 50, // Raio bem curto
                };
                
                this.defineUpgrades();
                this.initControls();
                this.createLevel();
                this.createClouds();
                this.updateUI();
                this.gameLoop();
            }

            defineUpgrades() {
                this.rarities = {
                    'Comum':    { color: '#95a5a6', weight: 100 },
                    'Incomum':  { color: '#2ecc71', weight: 50 },
                    'Raro':     { color: '#3498db', weight: 25 },
                    '√âpico':    { color: '#9b59b6', weight: 10 },
                    'Lend√°rio': { color: '#f1c40f', weight: 3 },
                    'PRIME':    { color: '#00e6e6', weight: 1 }
                };
                this.upgrades = [
                    // Comuns
                    { name: 'Propulsores Refor√ßados', icon: 'üöÄ', description: 'Aumenta permanentemente a altura do pulo.', rarity: 'Comum', apply: () => this.jumpPower -= 2 },
                    { name: 'Servomotores Otimizados', icon: '‚öôÔ∏è', description: 'Aumenta permanentemente a velocidade de movimento.', rarity: 'Comum', apply: () => this.moveSpeed += 0.75 },
                    { name: 'Placas de Tit√¢nio', icon: 'üß±', description: 'Aumenta a vida m√°xima em 25 e cura a mesma quantidade.', rarity: 'Comum', apply: () => { this.playerState.maxHp += 25; this.playerState.hp += 25; }},
                    { name: 'Capacitor de Energia', icon: 'üîã', description: 'Otimiza os sistemas de aprendizagem, aumentando todo o ganho de EXP em 15%.', rarity: 'Comum', apply: () => this.playerState.expMultiplier += 0.15},
                    { name: 'Scanner de Amea√ßas', icon: 'üì°', description: 'Instala um scanner que exibe a barra de vida de todos os inimigos.', rarity: 'Comum', apply: () => this.enemyHpBarsVisible = true },
                    // Incomuns
                    { name: 'Resfriamento Aprimorado', icon: 'üïë', description: 'Aumenta a velocidade de tiro em 15%.', rarity: 'Incomum', apply: () => this.shootCooldown *= 0.85 },
                    { name: 'Otimizador de Muni√ß√£o', icon: 'üî´', description: 'Melhora os proj√©teis, aumentando o dano base em 1 permanentemente.', rarity: 'Incomum', apply: () => this.playerState.baseProjectileDamage += 1},
                    { name: 'Overclock', icon: '‚è∞', description: 'Aumenta a velocidade de disparo em 30%, sacrificando sua vida m√°xima.', rarity: 'Incomum', apply: () => {this.shootCooldown *= 0.70; this.playerState.maxHp -= 25; this.playerState.hp -= 25;}},                    
                    { name: 'Blindagem Revestida', icon: 'üõ°Ô∏è', description: 'Reduz todo o dano recebido em 10%. Acumul√°vel.', rarity: 'Incomum', apply: () => this.playerState.damageReduction += 0.10 },
                    { name: 'Coletor de Sucata', icon: 'üõ†', description: 'Inimigos t√™m 10% de chance de soltar um orbe de reparo ao serem destru√≠dos.', rarity: 'Incomum', apply: () => this.scrapChance += 0.10},
                    { name: 'Muni√ß√£o Criog√™nica', icon: '‚ùÑÔ∏è', description: 'Seus proj√©teis t√™m +20% de chance de desacelerar inimigos por 3 segundos.', rarity: 'Incomum', apply: () => this.cryoChance += 0.20 },
                    { name: 'Sobrecarga de Energia', icon: '‚ö°', description: 'Melhora os capacitores, aumentando a Energia m√°xima em 25 e a sua regenera√ß√£o.', rarity: 'Incomum', apply: () => {this.playerState.maxEnergy += 25; this.playerState.energyRegenRate += 0.05;}},
                    { name: 'V√≠rus Corrosivo', icon: 'ü¶†', description: 'Proj√©teis t√™m 10% de chance de infectar inimigos, causando dano cont√≠nuo e reduzindo sua velocidade de tiro.', rarity: 'Incomum', apply: () => this.corrosiveVirusChance += 0.10},
                    { name: 'Propulsores Auxiliares', icon: 'üëü', description: 'Instala propulsores secund√°rios que permitem um pulo duplo. (N√£o acumul√°vel)', rarity: 'Incomum', apply: () => { if (this.playerState.maxJumps < 2) {this.playerState.maxJumps = 2;}}},
                    // Raros
                    { name: 'Canh√£o de Plasma Duplo', icon: '‚ôä', description: 'Atira um proj√©til extra a cada disparo.', rarity: 'Raro', apply: () => this.playerState.extraProjectiles++ },
                    { name: 'Nano-Reparadores', icon: '‚ù§Ô∏è‚Äçü©π', description: 'Regenera 1 HP a cada 4 segundos.', rarity: 'Raro', apply: () => this.playerState.hpRegen += 0.25 },
                    { name: 'Campo de For√ßa Reativo', icon: 'üßø', description: 'Aumenta a dura√ß√£o da invencibilidade em 1 segundo.', rarity: 'Raro', apply: () => this.invincibilityDuration += 1000 },
                    { name: 'Muni√ß√£o Inst√°vel', icon: 'üí•', description: 'Seus proj√©teis t√™m +15% de chance de explodir ao contato.', rarity: 'Raro', apply: () => this.explosiveShotChance += 0.15 },
                    { name: 'Protocolo de Vingan√ßa', icon: 'üí¢', description: 'Ao sofrer dano, dispara 8 proj√©teis em um c√≠rculo ao seu redor.', rarity: 'Raro', apply: () => this.vengeanceProtocolActive = true },
                    { name: 'Aumentar Calibre', icon: '‚ûï', description: 'Aumenta o tamanho dos seus proj√©teis, facilitando acertar os inimigos.', rarity: 'Raro', apply: () => this.playerState.projectileSize += 2},
                    { name: 'Sif√£o de Vitalidade', icon: 'ü©∏', description: 'Seus proj√©teis t√™m +5% de chance de drenar a energia vital dos inimigos, curando voc√™.', rarity: 'Raro', apply: () => this.lifestealChance += 0.05},
                    { name: 'M√≥dulo de Fragmenta√ß√£o', icon: 'üîÜ', description: 'Inimigos destru√≠dos explodem em 3 estilha√ßos que causam dano a outros inimigos. Pegar novamente aumenta o n√∫mero de estilha√ßos.', rarity: 'Raro', apply: () => { if (!this.fragmentationModule.active) { this.fragmentationModule.active = true; } else { this.fragmentationModule.numFragments++; }}},
                    { name: 'M√≥dulo Serras Circulares', icon: 'üíø', description: 'Cria uma serra orbital que causa dano de contato a inimigos pr√≥ximos. Acumul√°vel.', rarity: 'Raro', apply: () => { this.addOrbitalSaw();}},
                    { name: 'Escudo de Energia', icon: 'üåê', description: 'Gera um escudo que bloqueia um proj√©til inimigo. Recarrega ap√≥s 8 segundos.', rarity: 'Raro',
                        apply: () => {
                            if (!this.energyShield.active) {
                                this.energyShield.active = true;
                                this.energyShield.ready = true;
                                // Cria o elemento visual do escudo e anexa-o ao jogador
                                const shieldElement = document.createElement('div');
                                shieldElement.className = 'energy-shield';
                                this.player.appendChild(shieldElement);
                                this.energyShield.element = shieldElement;
                            } else {
                                // Se j√° tiver, melhora o tempo de recarga
                                this.energyShield.cooldown = Math.max(3000, this.energyShield.cooldown * 0.8);
                            }
                        },
                    },
                    { name: 'Propulsor de Esquiva', icon: '‚Üî', description: 'Aperte duas vezes A ou D para uma esquiva r√°pida na dire√ß√£o do movimento. ++Diminui Cooldown', rarity: 'Raro',
                        apply: () => {
                            if (this.dashEnabled){
                                this.dashEnabled = true
                            } else {
                                this.dashCooldown -= 250
                            }
                        }
                        
                    },
                    // √âpicos
                    { name: 'M√≥dulo de Singularidade', icon: 'üß¨', description: 'Reduz drasticamente o cooldown de tiro (30%).', rarity: '√âpico', apply: () => this.shootCooldown *= 0.70 },
                    { name: 'Overdrive de Combate', icon: 'üìõ', description: 'Aumenta permanentemente a velocidade dos seus proj√©teis.', rarity: '√âpico', apply: () => this.projectileSpeed += 3 },
                    { name: 'N√∫cleo de Energia Vital', icon: 'ü´Ä', description: 'Aumenta a integridade m√°xima do chassi (HP) em +50.', rarity: '√âpico', apply: () => { this.playerState.maxHp += 50; this.playerState.hp += 50;}},
                    { name: 'Drone de Combate', icon: 'ü§ñ', description: 'Cria um drone auxiliar que atira nos inimigos. ++Pegar novamente melhora o drone.', rarity: '√âpico', apply: () => { if (!this.droneState.active) { this.droneState.active = true; this.droneState.x = this.playerState.x; this.droneState.y = this.playerState.y - 50; this.droneElement.style.display = 'block'; } else { this.droneState.shootCooldown *= 0.8; }}},
                    { name: 'Emissor de Pulsos', icon: 'üéÜ', description: 'A cada 5s, emite um pulso de energia que causa dano a inimigos pr√≥ximos. Pegar novamente melhora o pulso.', rarity: '√âpico', apply: () => { if (!this.pulseEmitter.active) { this.pulseEmitter.active = true; this.pulseEmitter.lastPulse = Date.now(); } else { this.pulseEmitter.cooldown *= 0.85; this.pulseEmitter.damage += 2; }}},
                    { name: 'Carga Est√°tica', icon: '‚ú®', description: 'Emite um campo de energia de curto alcance que causa dano cont√≠nuo a inimigos pr√≥ximos. ++Aumenta Dano', rarity: '√âpico',
                        apply: () => {
                            if (!this.staticCharge.active) {
                                this.staticCharge.active = true;
                            } else {
                                // Melhora o upgrade se j√° o tiver
                                this.staticCharge.damage += 0.5;
                                this.staticCharge.radius += 10;
                            }
                        }
                    },
                    { name: 'Torreta Estacion√°ria', icon: 'üóº', description: 'Cria uma torreta defensiva no ch√£o. M√°ximo de duas. Pegar novamente aumenta o dano das existentes.', rarity: '√âpico',
                        apply: () => {
                            const numTurrets = this.turrets.length;
                            if (numTurrets < 2) {
                                // Se ainda n√£o temos duas torretas, vamos criar uma nova
                                const hasLeft = this.turrets.some(t => t.side === 'left');
                                const hasRight = this.turrets.some(t => t.side === 'right');

                                if (!hasLeft && !hasRight) {
                                    // Se n√£o tem nenhuma, cria a do lado mais pr√≥ximo do jogador
                                    const side = this.playerState.x < 512 ? 'left' : 'right';
                                    this.createTurret(side);
                                } else if (hasLeft && !hasRight) {
                                    // Se j√° tem a da esquerda, cria a da direita
                                    this.createTurret('right');
                                } else if (!hasLeft && hasRight) {
                                    // Se j√° tem a da direita, cria a da esquerda
                                    this.createTurret('left');
                                }
                            } else {
                                // Se j√° tem duas, aumenta o dano de ambas
                                this.turrets.forEach(t => {
                                    t.damage += 0.5;
                                });
                            }
                        }
                    },
                    { name: 'Tempestade I√¥nica', icon: '‚õàÔ∏è', description: 'A cada 6 segundos, um raio ionizante cai do c√©u. Pegar novamente aumenta o n√∫mero de raios.', rarity: '√âpico',
                        apply: () => {
                            if (!this.ionicStorm.active) {
                                this.ionicStorm.active = true;
                                this.ionicStorm.lastStorm = Date.now(); // Inicia o timer
                            } else {
                                this.ionicStorm.numBolts += 2; // Aumenta o n√∫mero de raios
                            }
                        },
                    },
                    { name: 'Reator Cin√©tico', icon: 'üìà', description: 'Converte energia de movimento em poder de fogo. A cada certa dist√¢ncia percorrida, lan√ßa 3 foguetes para cima.', rarity: '√âpico',
                        apply: () => {
                            if (!this.kineticReactor.active) {
                                this.kineticReactor.active = true;
                            } else {
                                this.kineticReactor.numRockets++; // Aumenta o n√∫mero de foguetes
                                this.kineticReactor.distanceThreshold *= 0.9; // Precisa de menos dist√¢ncia para ativar
                            }
                        },
                    },                    
                    // Lend√°rios
                    { name: 'Reator de Mat√©ria Escura', icon: '‚ù§Ô∏è‚Äçüî•', description: 'Aumenta a vida m√°xima em 100 e a regenera√ß√£o de vida.', rarity: 'Lend√°rio', apply: () => { this.playerState.maxHp += 100; this.playerState.hp += 100; this.playerState.hpRegen += 1; }},
                    { name: 'M√≥dulo de Autoconserto', icon: 'üíñ', description: 'Lend√°rio: Instala nano-rob√¥s avan√ßados que aumentam drasticamente sua regenera√ß√£o de vida.', rarity: 'Lend√°rio', apply: () => this.playerState.hpRegen += 2},
                    { name: 'Protocolo F√™nix', icon: 'üïäÔ∏è', description: 'Lend√°rio: Se o seu HP chegar a 0, revive com 50% da vida e causa uma explos√£o massiva. (Uso √∫nico por upgrade)', rarity: 'Lend√°rio', apply: () => this.phoenixProtocolCharges++ },
                    { name: 'Protocolo Torre de Vigia', icon: 'üéØ', description: 'Lend√°rio: Ficar parado carrega sua arma, aumentando o dano. O b√≥nus √© perdido ao se mover.', rarity: 'Lend√°rio', apply: () => this.predatorFocus.active = true},
                    // PRIMES                    
                    { name: 'NITRO', icon: '‚è©', description: 'Segure SHIFT para um grande aumento na velocidade de movimento.', rarity: 'PRIME', apply: () => this.activePrimeUpgrade = 'NITRO' },
                    { name: 'BLINDAGEM M√ÅXIMA', icon: 'üí†', description: 'Segure SHIFT para ficar im√≥vel e invulner√°vel a todo o dano.', rarity: 'PRIME', apply: () => this.activePrimeUpgrade = 'BLINDAGEM_MAXIMA' },
                    { name: 'MEGAPROPULS√ÉO', icon: '‚öú', description: 'Segure SHIFT para sobrecarregar sua arma, aumentando o dano e a velocidade dos proj√©teis.', rarity: 'PRIME', apply: () => this.activePrimeUpgrade = 'MEGAPROPULSAO' },
                    { name: 'MATRIX', icon: 'üß†', description: 'Segure SHIFT para distorcer o tempo, reduzindo drasticamente a velocidade dos proj√©teis inimigos.', rarity: 'PRIME', apply: () => this.activePrimeUpgrade = 'MATRIX' },
                    { name: 'BOMBARDEIO', icon: 'üí£', description: 'Segure SHIFT para chamar um bombardeio a√©reo cont√≠nuo na √°rea.', rarity: 'PRIME', apply: () => this.activePrimeUpgrade = 'BOMBARDEIO' },
                    { name: 'PROTOCOLO: MECHA', icon: 'ü¶ç', description: 'Transforma permanentemente seu rob√¥ num MECHA de combate. Muito maior, mais resistente e com canh√µes duplos.', rarity: 'PRIME',
                        apply: () => {
                            // S√≥ aplica a transforma√ß√£o uma vez
                            if (this.playerState.isMecha) return;

                            this.playerState.isMecha = true;                            
                            this.playerState.width = 40;
                            this.playerState.height = 50;
                            this.playerState.damageReduction += 0.50;
                            this.playerState.baseProjectileDamage += 2; 
                            
                            this.player.classList.add('mecha-active');
                        },
                    },
                ];
            }

            updateUpgradeTrackerUI() {
                const trackerContainer = document.getElementById('upgradeTracker');
                trackerContainer.innerHTML = ''; // Limpa tudo para redesenhar do zero

                // Se n√£o houver upgrades, n√£o faz nada
                if (this.collectedUpgrades.size === 0) {
                    return;
                }

                // --- NOVA L√ìGICA DE COLUNAS ---
                let iconCountInCurrentColumn = 0;

                // 1. Cria a primeira coluna
                let currentColumn = document.createElement('div');
                currentColumn.className = 'upgrade-column';
                trackerContainer.appendChild(currentColumn);

                // 2. Itera sobre os upgrades coletados
                for (const [name, data] of this.collectedUpgrades) {
                    // 3. Verifica se a coluna atual est√° cheia (com 6 √≠cones)
                    if (iconCountInCurrentColumn === 6) {
                        // Se estiver cheia, cria uma nova coluna
                        currentColumn = document.createElement('div');
                        currentColumn.className = 'upgrade-column';
                        trackerContainer.appendChild(currentColumn);
                        
                        // Zera o contador para a nova coluna
                        iconCountInCurrentColumn = 0;
                    }

                    // 4. Cria o elemento do √≠cone (l√≥gica existente)
                    const iconContainer = document.createElement('div');
                    iconContainer.className = 'tracker-icon-container';
                    const stackText = data.stacks > 1 
                        ? `<span class="tracker-stack-count">${data.stacks}</span>` 
                        : '';
                    iconContainer.innerHTML = `
                        <div class="tracker-icon" title="${name}">${data.icon}</div>
                        ${stackText}
                    `;
                    
                    // 5. Adiciona o √≠cone √† coluna atual
                    currentColumn.appendChild(iconContainer);
                    
                    // 6. Incrementa o contador de √≠cones na coluna
                    iconCountInCurrentColumn++;
                }
            }

            initControls() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    // --- L√ìGICA DO DASH ---
                    if (this.dashEnabled && (e.code === 'KeyA' || e.code === 'KeyD')) {
                        const now = Date.now();
                        // Se a mesma tecla foi pressionada h√° menos de 500ms
                        if (now - this.lastKeyPress[e.code] < 500 && now - this.lastDashTime > this.dashCooldown) {
                            this.triggerDash(e.code === 'KeyD' ? 1 : -1); // 1 para direita, -1 para esquerda
                        }
                        this.lastKeyPress[e.code] = now;
                    }
                });
                
                document.addEventListener('keyup', (e) => this.keys[e.code] = false);
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                this.canvas.addEventListener('mousedown', () => this.mouse.pressed = true);
                document.addEventListener('mouseup', () => this.mouse.pressed = false);
            }

            createLevel() {
                const groundY = 570;
                for (let x = 0; x < 1024; x += 20) this.createBlock(x, groundY, 20, 30);
                for (let i = 0; i < 8; i++) {
                    this.createBlock(i * 25, groundY - (i + 1) * 20, 20, 20);
                    this.createBlock(1024 - (i + 1) * 25, groundY - (i + 1) * 20, 20, 20);
                }
                for (let x = 400; x < 624; x += 20) this.createBlock(x, 500, 20, 20);
                this.createTower(80, 350, 40, 120);
                this.createTower(150, 380, 30, 90);
                this.createTower(880, 320, 45, 150);
                this.createTower(820, 400, 30, 70);
            }

            createBlock(x, y, width, height) {
                const block = document.createElement('div');
                block.className = 'block';
                block.style.left = x + 'px';
                block.style.top = y + 'px';
                block.style.width = width + 'px';
                block.style.height = height + 'px';
                this.gameObjectsContainer.appendChild(block);
                this.blocks.push({ x, y, width, height, element: block });
            }

            createTower(x, y, width, height) {
                const tower = document.createElement('div');
                tower.className = 'tower';
                tower.style.left = x + 'px';
                tower.style.top = y + 'px';
                tower.style.width = width + 'px';
                tower.style.height = height + 'px';
                this.gameObjectsContainer.appendChild(tower);
                this.blocks.push({ x, y, width, height, element: tower });
            }

            createClouds() {
                [{x: 100, y: 80, w: 40, h: 20}, {x: 350, y: 60, w: 50, h: 25}, {x: 600, y: 90, w: 35, h: 18}, {x: 800, y: 70, w: 45, h: 22}]
                .forEach(pos => {
                    const cloud = document.createElement('div');
                    cloud.className = 'cloud';
                    cloud.style.left = pos.x + 'px';
                    cloud.style.top = pos.y + 'px';
                    cloud.style.width = pos.w + 'px';
                    cloud.style.height = pos.h + 'px';
                    this.gameObjectsContainer.appendChild(cloud);
                });
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            updatePlayer() {
                let currentMoveSpeed = this.primeEffects.isNitroActive ? this.moveSpeed * 2.5 : this.moveSpeed;

                if (this.primeEffects.isShieldActive) {
                    this.playerState.vx = 0; // Para o jogador completamente
                } else {
                    if (this.keys['KeyA'] || this.keys['ArrowLeft']) this.playerState.vx = -currentMoveSpeed;
                    else if (this.keys['KeyD'] || this.keys['ArrowRight']) this.playerState.vx = currentMoveSpeed;
                    else if (!this.playerState.isDashing) {
                        this.playerState.vx *= 0.8;
                    }

                    // Verifica se a tecla de pulo foi pressionada e se o jogador ainda tem pulos dispon√≠veis
                    if ((this.keys['Space'] || this.keys['KeyW'] || this.keys['ArrowUp']) && this.playerState.jumpsUsed < this.playerState.maxJumps) {
                        // Impede que o jogador "gaste" o pulo duplo se ainda estiver a pressionar a tecla do primeiro pulo
                        if (!this.keys.jumpHeld) { 
                            this.playerState.vy = this.jumpPower;
                            this.playerState.jumpsUsed++;
                            this.keys.jumpHeld = true; // Marca que a tecla est√° pressionada para este pulo
                            this.playerState.onGround = false; // Garante que o estado 'onGround' √© falso para pulos a√©reos
                        }
                    }
                    // Deteta quando a tecla de pulo √© solta
                    if (!(this.keys['Space'] || this.keys['KeyW'] || this.keys['ArrowUp'])) {
                        this.keys.jumpHeld = false;
                    }if ((this.keys['Space'] || this.keys['KeyW'] || this.keys['ArrowUp']) && this.playerState.onGround) {
                            this.playerState.vy = this.jumpPower;
                            this.playerState.onGround = false;
                        }
                }
                
                this.playerState.x += this.playerState.vx;
                for (const block of this.blocks) {
                    if (this.checkCollision(this.playerState, block)) {
                        if (this.playerState.vx > 0) this.playerState.x = block.x - this.playerState.width;
                        else if (this.playerState.vx < 0) this.playerState.x = block.x + block.width;
                        this.playerState.vx = 0;
                    }
                }

                this.playerState.vy += this.gravity;
                this.playerState.y += this.playerState.vy;

                this.playerState.onGround = false;
                for (const block of this.blocks) {
                    if (this.checkCollision(this.playerState, block)) {
                        if (this.playerState.vy > 0) {
                            this.playerState.y = block.y - this.playerState.height;
                            this.playerState.onGround = true;
                            this.playerState.vy = 0;
                            this.playerState.jumpsUsed = 0; // Reinicia os pulos ao tocar no ch√£o
                        } else if (this.playerState.vy < 0) {
                            this.playerState.y = block.y + block.height;
                            this.playerState.vy = 0;
                        }
                    }
                }
                
                if (this.playerState.x < 0) this.playerState.x = 0;
                if (this.playerState.x > this.canvas.offsetWidth - this.playerState.width) {
                    this.playerState.x = this.canvas.offsetWidth - this.playerState.width;
                }
                
                this.player.style.left = this.playerState.x + 'px';
                this.player.style.top = this.playerState.y + 'px';

                 // --- L√ìGICA DO FOCO DO PREDADOR ---
                if (this.predatorFocus.active) {
                    // Se o jogador est√° praticamente parado
                    if (Math.abs(this.playerState.vx) < 0.1 && this.playerState.onGround) {
                        this.predatorFocus.timeStill += 16; // Adiciona o tempo de 1 frame (aprox.)
                        // A cada 1 segundo parado (1000ms), ganha +1 de dano
                        if (this.predatorFocus.timeStill % 1000 < 16) { 
                           this.predatorFocus.bonusDamage = Math.floor(this.predatorFocus.timeStill / 1000);
                        }
                    } else {
                        // Se moveu, zera o b√≥nus
                        this.predatorFocus.timeStill = 0;
                        this.predatorFocus.bonusDamage = 0;
                    }
                }

                if (this.kineticReactor.active) {
                    this.kineticReactor.distanceMeter += Math.abs(this.playerState.vx);
                }
            }

            spawnEnemy() {
                if (this.gameState !== 'survival') return;
                if (Date.now() - this.lastEnemySpawn < this.enemySpawnRate) return;

                // 1. Filtra os inimigos que podem aparecer com base no tempo de jogo
                const availableEnemies = this.enemyCatalog.filter(e => this.gameTime >= e.minTime);

               // 2. Cria uma "piscina de sorteio" baseada nos pesos
                const spawnPool = [];
                for (const enemy of availableEnemies) {
                    // Adiciona o tipo de inimigo √† piscina um n√∫mero de vezes igual ao seu peso
                    for (let i = 0; i < enemy.weight; i++) {
                        spawnPool.push(enemy.type);
                    }
                }

                const enemyType = spawnPool.length > 0
                    ? spawnPool[Math.floor(Math.random() * spawnPool.length)]
                    : 'Vigia';

                let enemy;                
                switch(enemyType) {
                    case 'Ariete':
                        enemy = this.createAriete();
                        break;
                    case 'UnidadeInstavel':
                        enemy = this.createUnidadeInstavel();
                        break;
                    case 'Ceifador':
                        enemy = this.createCeifador();
                        break;  
                    case 'Bombardeiro':
                        enemy = this.createBombardeiro();
                        break;      
                    case 'Bastiao':
                        enemy = this.createBastiao();
                        break;
                    case 'DroneMedico':
                        enemy = this.createDroneMedico();
                        break;    
                    case 'Vespa':
                        enemy = this.createVespa();
                        break;    
                    case 'Vigia':
                    default:
                        enemy = this.createVigia();
                        break;
                }

                // Adiciona o inimigo criado ao jogo
                this.gameObjectsContainer.appendChild(enemy.element);
                this.enemies.push(enemy);

                this.lastEnemySpawn = Date.now();
                const difficulty = Math.floor(this.gameTime / 60000) + 1;
                this.enemySpawnRate = Math.max(800, 2000 - (difficulty * 100));
            }

            createVigia() {
                const difficulty = Math.floor(this.gameTime / 60000) + 1;
                const enemy = {
                    type: 'Vigia', // Identificador do tipo
                    x: Math.random() * 1000 + 12, y: -20, vx: 0, vy: 0,
                    width: 16, height: 16,
                    hp: 1 + difficulty, maxHp: 1 + difficulty,
                    state: 'falling',
                    stopY: (this.canvas.offsetHeight * 0.35) + (Math.random() - 0.5) * 120,
                    lastShot: 0, shootCooldown: 3000,
                    isCorroded: false,
                    corrodedUntil: 0,
                    lastDoTTick: 0,
                    hasShield: false,
                    shieldHp: 0,
                    shieldElement: null,
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy vigia'; // Adiciona a classe espec√≠fica
                // L√≥gica de cria√ß√£o da barra de vida...
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                return enemy;
            }

            // 1. CORRE√á√ÉO NO CREATEARIETE
            createAriete() {
                const difficulty = Math.floor(this.gameTime / 60000) + 1;
                const enemy = {
                    type: 'Ariete',
                    x: Math.random() > 0.5 ? -30 : 1054, y: Math.random() * 200,
                    vx: 0, vy: 0,
                    width: 24, height: 18,
                    hp: 2 + difficulty, maxHp: 2 + difficulty,
                    state: 'idling',
                    lastCharge: Date.now(), chargeCooldown: 3000,
                    chargeSpeed: 8,
                    collisionDamage: 20,
                    isCorroded: false,
                    corrodedUntil: 0,
                    lastDoTTick: 0,
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy ariete';
                
                // --- C√ìDIGO DA BARRA DE VIDA COMPLETO ---
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                // --- FIM DO C√ìDIGO COMPLETO ---
                
                return enemy;
            }

            createVespa() {
                const difficulty = Math.floor(this.gameTime / 60000) + 1;
                const enemy = {
                    type: 'Vespa',
                    x: Math.random() * 1000 + 12, y: -20, vx: 0, vy: 0,
                    width: 12, height: 12,
                    hp: 1 + difficulty, maxHp: 1 + difficulty,
                    followSpeed: 2.5, 
                    shootRange: 80, // S√≥ atira se estiver a 80px ou menos do jogador
                    lastShot: 0, shootCooldown: 1500, 
                    isCorroded: false,
                    corrodedUntil: 0,
                    lastDoTTick: 0,
                    hasShield: false,
                    shieldHp: 0,
                    shieldElement: null,
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy vespa';
                
                // Adiciona a barra de vida, como nos outros
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                
                return enemy;
            }

            // 2. CORRE√á√ÉO NO CREATEUNIDADEINSTAVEL
            createUnidadeInstavel() {
                const difficulty = Math.floor(this.gameTime / 60000) + 1;
                const enemy = {
                    type: 'UnidadeInstavel',
                    x: Math.random() * 1000 + 12, y: -20, vx: 0, vy: 0,
                    width: 18, height: 18,
                    hp: 4 + difficulty, maxHp: 4 + difficulty,
                    state: 'seeking',
                    followSpeed: 1.5,
                    detonationTimer: 0, detonationDuration: 2000,
                    explosionRadius: 90, explosionDamage: 35,
                    hasShield: false,
                    shieldHp: 0,
                    shieldElement: null,
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy unidade-instavel';

                // --- C√ìDIGO DA BARRA DE VIDA COMPLETO ---
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                // --- FIM DO C√ìDIGO COMPLETO ---

                return enemy;
            }

            createCeifador() {
                // Cria o elemento da mira laser
                const laserElement = document.createElement('div');
                laserElement.className = 'laser-sight';
                this.gameObjectsContainer.appendChild(laserElement);

                const enemy = {
                    type: 'Ceifador',
                    x: Math.random() * 900 + 62, y: -20, vx: 0, vy: 0,
                    width: 22, height: 14,
                    hp: 12, maxHp: 12,
                    isCorroded: false,
                    corrodedUntil: 0,
                    lastDoTTick: 0, 
                    hasShield: false,
                    shieldHp: 0,
                    shieldElement: null,
                    state: 'repositioning', // 'repositioning', 'aiming', 'firing', 'cooldown'
                    targetPosition: null, // O "ninho de sniper" que ele busca
                    
                    laserElement: laserElement, // Refer√™ncia ao seu elemento de mira
                    aimStartTime: 0,
                    aimDuration: 1500, // 1.5 segundos de mira
                    
                    lastActionTime: Date.now(),
                    cooldown: 2000, // 2 segundos de espera ap√≥s atirar
                    
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy ceifador';
                
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                
                return enemy;
            }

            enemyShootSniper(enemy, target) {
                const p = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                const dx = target.x - p.x, dy = target.y - p.y;
                const dist = Math.hypot(dx, dy);
                const proj = {
                    x: p.x, y: p.y,
                    vx: (dx / dist) * 12, // ALTA VELOCIDADE
                    vy: (dy / dist) * 12,
                    damage: 50, // ALTO DANO
                    element: document.createElement('div')
                };
                proj.element.className = 'sniper-shot'; // Usa a classe CSS do tiro de sniper
                this.gameObjectsContainer.appendChild(proj.element);
                this.enemyProjectiles.push(proj);
            }

            // 3. CORRE√á√ÉO NO CREATEBASTIAO
            createBastiao() {
                const difficulty = Math.floor(this.gameTime / 60000) + 1;
                const enemy = {
                    type: 'Bastiao',
                    x: Math.random() * 900 + 62, y: -50, vx: 0, vy: 0,
                    width: 40, height: 40,
                    hp: 10 * difficulty, maxHp: 10 * difficulty,
                    state: 'falling',
                    stopY: (this.canvas.offsetHeight * 0.25) + (Math.random() - 0.5) * 80,
                    followSpeed: 0.5,
                    lastShot: 0, shootCooldown: 4000,
                    isCorroded: false,
                    corrodedUntil: 0,
                    lastDoTTick: 0,
                    hasShield: false,
                    shieldHp: 0,
                    shieldElement: null,
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy bastiao';
                
                // --- C√ìDIGO DA BARRA DE VIDA COMPLETO ---
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                // --- FIM DO C√ìDIGO COMPLETO ---
                
                return enemy;
            }

            // Nova fun√ß√£o de tiro para o Basti√£o
            enemyShootBurst(enemy) {
                // Dispara 3 proj√©teis em uma rajada
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        if (enemy.hp <= 0) return; // N√£o atira se j√° morreu
                        const p = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                        const player = { x: this.playerState.x + this.playerState.width / 2, y: this.playerState.y + this.playerState.height / 2 };
                        const dx = player.x - p.x, dy = player.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const proj = { x: p.x, y: p.y, vx: (dx / dist) * 3, vy: (dy / dist) * 3, element: document.createElement('div') };
                        proj.element.className = 'heavy-plasma'; // Usa o CSS do proj√©til pesado
                        this.gameObjectsContainer.appendChild(proj.element);
                        this.enemyProjectiles.push(proj);
                    }, i * 200); // Atraso de 200ms entre cada tiro da rajada
                }
            }

            createBombardeiro() {
                const enemy = {
                    type: 'Bombardeiro',
                    x: Math.random() * 900 + 62, y: 40, // Nasce no topo do ecr√£
                    vx: 0, vy: 0,
                    width: 36, height: 16,
                    hp: 15, maxHp: 15,
                    patrolSpeed: 1.5,
                    moveDirection: Math.random() > 0.5 ? 1 : -1, // 1 para direita, -1 para esquerda
                    timeSinceDirChange: Date.now(),
                    dirChangeCooldown: 3000, 
                    lastBombDrop: Date.now(),
                    bombDropCooldown: 2000,
                    hasShield: false,
                    shieldHp: 0,
                    shieldElement: null, 
                    element: document.createElement('div'),
                };
                enemy.element.className = 'enemy bombardeiro';
                
                // Adiciona a barra de vida
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                
                return enemy;
            }

            spawnFallingBomb(x, y) {
                const bomb = {
                    x: x, y: y,
                    vy: 3, // Velocidade de queda da bomba
                    width: 12, height: 12,
                    explosionRadius: 50,
                    explosionDamage: 15,
                    element: document.createElement('div')
                };
                bomb.element.className = 'falling-bomb';

                bomb.element.style.left = bomb.x + 'px';
                bomb.element.style.top = bomb.y + 'px';

                this.gameObjectsContainer.appendChild(bomb.element);
                this.fallingBombs.push(bomb);
            }

            updateFallingBombs() {
                for (let i = this.fallingBombs.length - 1; i >= 0; i--) {
                    const bomb = this.fallingBombs[i];
                    
                    // Move a bomba para baixo
                    bomb.y += bomb.vy;
                    bomb.element.style.top = bomb.y + 'px';

                    // Verifica colis√£o com as plataformas/ch√£o
                    let hitGround = false;
                    for (const block of this.blocks) {
                        if (this.checkCollision(bomb, block)) {
                            hitGround = true;
                            break;
                        }
                    }

                    // Se atingiu o ch√£o ou saiu da tela por baixo
                    if (hitGround || bomb.y > this.canvas.offsetHeight) {
                        this.createExplosion(bomb.x, bomb.y, bomb.explosionRadius, bomb.explosionDamage);
                        bomb.element.remove();
                        this.fallingBombs.splice(i, 1);
                    }
                }
            }

            createDroneMedico() {
                const beamElement = document.createElement('div');
                beamElement.className = 'healing-beam';
                this.gameObjectsContainer.appendChild(beamElement);

                const enemy = {
                    type: 'DroneMedico',
                    x: Math.random() * 900 + 62, y: 50,
                    vx: 0, vy: 0,
                    width: 20, height: 20,
                    hp: 3, maxHp: 3,
                    state: 'finding_target', // 'finding_target', 'healing'
                    patrolSpeed: 1,
                    moveDirection: Math.random() > 0.5 ? 1 : -1,
                    targetAlly: null, // O drone que est√° a ser curado
                    healingBeamElement: beamElement,
                    lastHealTime: 0,
                    element: document.createElement('div'),
                    // Drones m√©dicos n√£o podem ser curados ou escudados
                    hasShield: false, shieldHp: 0, shieldElement: null,
                };
                enemy.element.className = 'enemy drone-medico';
                
                const hpBarContainer = document.createElement('div');
                hpBarContainer.className = 'enemy-hp-bar-container';
                const hpBarFill = document.createElement('div');
                hpBarFill.className = 'enemy-hp-bar-fill';
                hpBarContainer.appendChild(hpBarFill);
                enemy.element.appendChild(hpBarContainer);
                enemy.hpBar = { container: hpBarContainer, fill: hpBarFill };
                
                return enemy;
            }

            updateEnemies() {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    // Garante que o inimigo ainda existe no array antes de continuar
                    if (!this.enemies[i]) continue;
                    const enemy = this.enemies[i];
                    
                    if (enemy.hp <= 0) {
                        if (enemy.type === 'UnidadeInstavel') { this.createExplosion(enemy.x, enemy.y, enemy.explosionRadius, enemy.explosionDamage); }
                        if (enemy.type === 'Ceifador') { enemy.laserElement.remove(); }
                        if (enemy.type === 'DroneMedico') { enemy.healingBeamElement.remove(); }
                        if (this.fragmentationModule.active) { this.triggerFragmentation(enemy); }
                        enemy.element.remove();
                        this.playSound_enemyDeath();
                        this.enemies.splice(i, 1);
                        this.enemiesKilled++;
                        this.gainExp(10 + Math.floor(this.gameTime / 10000) * 5);
                        continue;
                    }

                    if (this.enemyHpBarsVisible) {
                        enemy.hpBar.container.style.display = 'block';
                        enemy.hpBar.fill.style.width = Math.max(0, (enemy.hp / enemy.maxHp) * 100) + '%';
                    }

                    let speedMultiplier = 1.0;
                    if (enemy.isSlowed) {
                        if (Date.now() > enemy.slowedUntil) {
                            enemy.isSlowed = false;
                            enemy.element.style.backgroundColor = enemy.originalColor;
                        } else {
                            speedMultiplier = 0.5;
                        }
                    }

                    let fireRateMultiplier = 1.0;
                    if (enemy.isCorroded) {
                        fireRateMultiplier = 1.5;
                        if (Date.now() > enemy.corrodedUntil) {
                            enemy.isCorroded = false;
                            enemy.element.classList.remove('corroded');
                        } else if (Date.now() - enemy.lastDoTTick > 1000) {
                            enemy.hp -= enemy.maxHp * 0.10;
                            enemy.lastDoTTick = Date.now();
                        }
                    }

                    switch(enemy.type) {
                        case 'Vigia':
                        case 'Bastiao':
                            if (enemy.state === 'falling') {
                                enemy.y += (enemy.type === 'Bastiao' ? 1 : 2) * speedMultiplier;
                                if (enemy.y >= enemy.stopY) {
                                    enemy.state = 'following';
                                    enemy.lastShot = Date.now();
                                }
                            } else if (enemy.state === 'following') {
                                if (Date.now() - enemy.lastShot > enemy.shootCooldown * fireRateMultiplier) {
                                    if(enemy.type === 'Bastiao') this.enemyShootBurst(enemy);
                                    else this.enemyShoot(enemy);
                                    enemy.lastShot = Date.now();
                                }
                            }
                            break;
                        case 'Ariete':
                            if (enemy.state === 'idling' && Date.now() - enemy.lastCharge > enemy.chargeCooldown) {
                                enemy.state = 'charging';
                                const player = { x: this.playerState.x + this.playerState.width / 2, y: this.playerState.y + this.playerState.height / 2 };
                                const dx = player.x - enemy.x, dy = player.y - enemy.y;
                                const dist = Math.hypot(dx, dy);
                                if (dist > 0) {
                                    enemy.vx = (dx / dist) * enemy.chargeSpeed * speedMultiplier;
                                    enemy.vy = (dy / dist) * enemy.chargeSpeed * speedMultiplier;
                                }
                            } else if (enemy.state === 'charging') {
                                enemy.x += enemy.vx;
                                enemy.y += enemy.vy;
                                if(enemy.x < -100 || enemy.x > 1124 || enemy.y < -100 || enemy.y > 700) {
                                    enemy.hp = 0;
                                }
                            }
                            break;
                        case 'UnidadeInstavel':
                            const playerDist = Math.hypot(this.playerState.x - enemy.x, this.playerState.y - enemy.y);
                            if (enemy.state === 'seeking') {
                                if(playerDist < 70) {
                                    enemy.state = 'primed';
                                    enemy.detonationTimer = Date.now();
                                    enemy.element.classList.add('primed');
                                } else {
                                    const dx = this.playerState.x - enemy.x, dy = this.playerState.y - enemy.y;
                                    const dist = Math.hypot(dx, dy);
                                    if (dist > 0) {
                                        enemy.x += (dx/dist) * enemy.followSpeed * speedMultiplier;
                                        enemy.y += (dy/dist) * enemy.followSpeed * speedMultiplier;
                                    }
                                }
                            } else if (enemy.state === 'primed') {
                                if (Date.now() - enemy.detonationTimer > enemy.detonationDuration) {
                                    this.createExplosion(enemy.x, enemy.y, enemy.explosionRadius, enemy.explosionDamage);
                                    enemy.hp = 0;
                                }
                            }
                            break;
                        case 'Ceifador':
                             const pCenterCeifador = { x: this.playerState.x + this.playerState.width / 2, y: this.playerState.y + this.playerState.height / 2 };
                            if (enemy.state === 'repositioning') {
                                if (!enemy.targetPosition) {
                                    const topCornerX = (pCenterCeifador.x < 512) ? 950 : 50;
                                    enemy.targetPosition = { x: topCornerX, y: 60 };
                                }
                                const dx = enemy.targetPosition.x - enemy.x, dy = enemy.targetPosition.y - enemy.y;
                                const dist = Math.hypot(dx, dy);
                                if (dist > 5) {
                                    enemy.x += (dx / dist) * 3 * speedMultiplier;
                                    enemy.y += (dy / dist) * 3 * speedMultiplier;
                                } else {
                                    enemy.state = 'aiming';
                                    enemy.aimStartTime = Date.now();
                                    enemy.laserElement.style.display = 'block';
                                }
                            } else if (enemy.state === 'aiming') {
                                const dx = pCenterCeifador.x - (enemy.x + enemy.width / 2), dy = pCenterCeifador.y - (enemy.y + enemy.height / 2);
                                const distance = Math.hypot(dx, dy);
                                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                                enemy.laserElement.style.left = (enemy.x + enemy.width / 2) + 'px';
                                enemy.laserElement.style.top = (enemy.y + enemy.height / 2) + 'px';
                                enemy.laserElement.style.width = distance + 'px';
                                enemy.laserElement.style.transform = `rotate(${angle}deg)`;
                                if (Date.now() - enemy.aimStartTime > enemy.aimDuration) {
                                    enemy.state = 'firing';
                                }
                            } else if (enemy.state === 'firing') {
                                this.enemyShootSniper(enemy, pCenterCeifador);
                                enemy.laserElement.style.display = 'none';
                                enemy.state = 'cooldown';
                                enemy.lastActionTime = Date.now();
                            } else if (enemy.state === 'cooldown') {
                                if(Date.now() - enemy.lastActionTime > enemy.cooldown * fireRateMultiplier) {
                                    enemy.state = 'repositioning';
                                    enemy.targetPosition = null;
                                }
                            }
                            break;
                        case 'Vespa':
                            const pCenterVespa = { x: this.playerState.x + this.playerState.width / 2, y: this.playerState.y + this.playerState.height / 2 };
                            const eCenterVespa = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                            const dxVespa = pCenterVespa.x - eCenterVespa.x, dyVespa = pCenterVespa.y - eCenterVespa.y;
                            const pDistVespa = Math.hypot(dxVespa, dyVespa);
                            if (pDistVespa > 0) {
                                enemy.vx += (dxVespa / pDistVespa) * 0.1 * enemy.followSpeed * speedMultiplier;
                                enemy.vy += (dyVespa / pDistVespa) * 0.1 * enemy.followSpeed * speedMultiplier;
                            }
                            enemy.vx *= 0.95;
                            enemy.vy *= 0.95;
                            enemy.x += enemy.vx;
                            enemy.y += enemy.vy;
                            if (pDistVespa < enemy.shootRange && Date.now() - enemy.lastShot > enemy.shootCooldown * fireRateMultiplier) {
                                this.enemyShoot(enemy);
                                enemy.lastShot = Date.now();
                            }
                            break;
                        case 'Bombardeiro':
                            // 1. L√≥gica de Movimento de Patrulha
                            if (Date.now() - enemy.timeSinceDirChange > enemy.dirChangeCooldown) {
                                enemy.moveDirection *= -1; // Inverte a dire√ß√£o
                                enemy.timeSinceDirChange = Date.now();
                            }
                            // Move-se para os lados
                            enemy.x += enemy.patrolSpeed * enemy.moveDirection * speedMultiplier;

                            // Impede que saia da tela
                            if (enemy.x < 0 || enemy.x > this.canvas.offsetWidth - enemy.width) {
                                enemy.moveDirection *= -1;
                            }
                            
                            // 2. L√≥gica de Largar Bombas
                            if (Date.now() - enemy.lastBombDrop > enemy.bombDropCooldown) {
                                // Larga uma bomba a partir do centro do Bombardeiro
                                this.spawnFallingBomb(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                                enemy.lastBombDrop = Date.now();
                            }
                            break;                         
                        case 'DroneMedico':
                            // ESTADO 1: PROCURAR UM ALVO PARA CURAR
                            if (enemy.state === 'finding_target') {
                                enemy.targetAlly = null; // Zera o alvo anterior
                                let bestTarget = null;
                                let lowestHpPercent = 1;

                                // Procura o aliado com a menor percentagem de vida
                                for (const potentialTarget of this.enemies) {
                                    if (potentialTarget !== enemy && potentialTarget.type !== 'DroneMedico') {
                                        const hpPercent = potentialTarget.hp / potentialTarget.maxHp;
                                        if (hpPercent < lowestHpPercent) {
                                            lowestHpPercent = hpPercent;
                                            bestTarget = potentialTarget;
                                        }
                                    }
                                }
                                
                                if (bestTarget) {
                                    enemy.targetAlly = bestTarget;
                                    enemy.state = 'healing';
                                } else {
                                    // Se n√£o encontrar alvo, patrulha no topo da tela
                                    enemy.x += enemy.patrolSpeed * enemy.moveDirection * speedMultiplier;
                                    if (enemy.x < 0 || enemy.x > this.canvas.offsetWidth - enemy.width) {
                                        enemy.moveDirection *= -1;
                                    }
                                }
                            }
                            // ESTADO 2: CURAR O ALVO
                            else if (enemy.state === 'healing') {
                                const target = enemy.targetAlly;
                                // Se o alvo n√£o existe mais ou est√° com vida cheia, procura um novo
                                if (!target || target.hp <= 0 || target.hp === target.maxHp) {
                                    enemy.state = 'finding_target';
                                    enemy.healingBeamElement.style.display = 'none';
                                    if (target && target.shieldElement) { // Garante que o escudo do alvo anterior some
                                        target.shieldElement.remove();
                                        target.hasShield = false;
                                    }
                                    break;
                                }

                                // Atualiza a posi√ß√£o e rota√ß√£o do feixe de cura
                                const medicCenter = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                                const targetCenter = { x: target.x + target.width / 2, y: target.y + target.height / 2 };
                                const dx = targetCenter.x - medicCenter.x, dy = targetCenter.y - medicCenter.y;
                                const distance = Math.hypot(dx, dy);
                                const angle = Math.atan2(dy, dx) * (180 / Math.PI);

                                enemy.healingBeamElement.style.display = 'block';
                                enemy.healingBeamElement.style.left = medicCenter.x + 'px';
                                enemy.healingBeamElement.style.top = medicCenter.y + 'px';
                                enemy.healingBeamElement.style.width = distance + 'px';
                                enemy.healingBeamElement.style.transform = `rotate(${angle}deg)`;

                                // Aplica a cura e o escudo a cada segundo
                                if (Date.now() - enemy.lastHealTime > 1000) {
                                    target.hp = Math.min(target.maxHp, target.hp + 5); // Cura 5 HP/s
                                    
                                    // Concede ou renova o escudo
                                    if (!target.hasShield) {
                                        target.hasShield = true;
                                        target.shieldHp = 10; // Escudo que absorve 10 de dano
                                        const shieldEl = document.createElement('div');
                                        shieldEl.className = 'drone-shield';
                                        target.element.appendChild(shieldEl);
                                        target.shieldElement = shieldEl;
                                    } else {
                                        target.shieldHp = 10; // Renova a for√ßa do escudo
                                    }
                                    enemy.lastHealTime = Date.now();
                                }
                            }
                            break;       
                    }
                    
                    enemy.element.style.left = enemy.x + 'px';
                    enemy.element.style.top = enemy.y + 'px';
                    
                    for (let j = this.projectiles.length - 1; j >= 0; j--) {
                        const p = this.projectiles[j];
                        if (this.checkCollision(p, enemy)) {
                            if (enemy.hasShield) {
                                enemy.shieldHp -= p.damage; // O dano atinge primeiro o escudo
                                if (enemy.shieldHp <= 0) {
                                    enemy.hasShield = false;
                                    if(enemy.shieldElement) enemy.shieldElement.remove();
                                    enemy.shieldElement = null;
                                }
                            } else { enemy.hp -= p.damage;};

                            if (this.lifestealChance > 0 && Math.random() < this.lifestealChance) { this.playerState.hp = Math.min(this.playerState.maxHp, this.playerState.hp + this.lifestealAmount); }
                            if (this.cryoChance > 0 && Math.random() < this.cryoChance) { enemy.isSlowed = true; enemy.slowedUntil = Date.now() + 3000; enemy.element.style.backgroundColor = '#3498db'; }
                            if (this.explosiveShotChance > 0 && Math.random() < this.explosiveShotChance) { this.createExplosion(p.x + 2, p.y + 2); }
                            if (this.corrosiveVirusChance > 0 && Math.random() < this.corrosiveVirusChance && !enemy.isCorroded) { enemy.isCorroded = true; enemy.corrodedUntil = Date.now() + 5000; enemy.lastDoTTick = Date.now(); enemy.element.classList.add('corroded'); }
                            
                            p.element.remove();
                            this.projectiles.splice(j, 1);
                            break;
                        }
                    }

                    if (this.checkCollision(this.playerState, enemy)) {
                        if (enemy.type === 'Ariete' && enemy.state === 'charging') {
                            this.playerState.hp -= enemy.collisionDamage;
                            enemy.hp = 0;
                            if (!this.playerState.invincible) {
                                this.playerState.invincible = true;
                                this.playerState.invincibleTime = Date.now();
                                this.player.classList.add('invincible');
                            }
                            if (this.playerState.hp <= 0) { this.gameOver(); }
                        }
                    }
                }
            };

            enemyShoot(enemy) {
                const p = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                const player = { x: this.playerState.x + this.playerState.width / 2, y: this.playerState.y + this.playerState.height / 2 };
                const dx = player.x - p.x, dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const proj = { x: p.x, y: p.y, vx: (dx / dist) * 4, vy: (dy / dist) * 4, element: document.createElement('div') };
                proj.element.className = 'enemy-projectile';
                this.gameObjectsContainer.appendChild(proj.element);
                this.enemyProjectiles.push(proj);
            }

            updateEnergyShield() {
                if (!this.energyShield.active) return;

                // Se o escudo n√£o est√° pronto, verifica se j√° pode recarregar
                if (!this.energyShield.ready) {
                    if (Date.now() - this.energyShield.lastHitTime > this.energyShield.cooldown) {
                        this.energyShield.ready = true;
                        this.energyShield.element.style.opacity = '1'; // Torna o escudo vis√≠vel novamente
                    }
                }
            }

            updateEnemyProjectiles() {
                for (let i = this.enemyProjectiles.length - 1; i >= 0; i--) {
                    const p = this.enemyProjectiles[i];
                    let enemyProjectileSpeedMultiplier = this.primeEffects.isMatrixActive ? 0.2 : 1.0;
                    p.x += p.vx * enemyProjectileSpeedMultiplier;
                    p.y += p.vy * enemyProjectileSpeedMultiplier;
                    p.element.style.left = p.x + 'px';
                    p.element.style.top = p.y + 'px';

                    if (p.x < 0 || p.x > 1024 || p.y < 0 || p.y > 600) {
                        p.element.remove();
                        this.enemyProjectiles.splice(i, 1);
                        continue;
                    }

                    // --- L√ìGICA DO ESCUDO ---                    
                    if (this.energyShield.ready && this.checkCollision({x:p.x,y:p.y,width:3,height:3}, this.playerState)) {
                        this.energyShield.ready = false;
                        this.energyShield.lastHitTime = Date.now();
                        this.energyShield.element.style.opacity = '0';

                        p.element.remove();
                        this.enemyProjectiles.splice(i, 1);
                                                
                        continue; 
                    }
                    
                    // --- L√ìGICA DE DANO NO JOGADOR ---                    
                    if (!this.playerState.invincible && !this.primeEffects.isShieldActive && this.checkCollision({x:p.x,y:p.y,width:3,height:3}, this.playerState)) {
                        const damageTaken = (p.damage || 10) * (1 - this.playerState.damageReduction);
                        this.playerState.hp -= damageTaken;

                        if (this.vengeanceProtocolActive) { this.triggerVengeance(); }

                        if (this.playerState.hp <= 0) {
                            if (this.phoenixProtocolCharges > 0) {
                                this.phoenixProtocolCharges--;
                                this.playerState.hp = this.playerState.maxHp * 0.5;
                                this.playerState.invincible = true;
                                this.playerState.invincibleTime = Date.now() + 2500;
                                this.createExplosion(this.playerState.x + 10, this.playerState.y + 15, 200, 25, 'rgba(230, 126, 34, 0.8)');
                                this.enemies.forEach(e => e.element.remove());
                                this.enemies = [];
                            } else {
                                this.gameOver();
                            }
                        } else {
                            this.playerState.invincible = true;
                            this.playerState.invincibleTime = Date.now();
                            this.player.classList.add('invincible');
                        }
                        
                        p.element.remove();
                        this.enemyProjectiles.splice(i, 1);
                    }
                }
            }

            gainExp(amount) {
                this.playerState.exp += amount * this.playerState.expMultiplier;
                while (this.playerState.exp >= this.playerState.expToNext) {
                    this.playerState.exp -= this.playerState.expToNext;
                    this.playerState.level++;
                    if((this.playerState.hp += this.playerState.maxHp / 2) >= this.playerState.maxHp){
                        this.playerState.hp = this.playerState.maxHp
                    } else {this.playerState.hp += this.playerState.maxHp / 2;}                    
                    this.playerState.baseProjectileDamage += 0.1;
                    this.playSound_levelUp();
                    this.startLevelUp();
                    this.playerState.expToNext = Math.floor(this.playerState.expToNext * 1.5);
                }
            }

            updateEnergy() {
                const energyBar = document.getElementById('energyFill');
                const energyText = document.getElementById('energyText');

                // Se SHIFT n√£o est√° pressionado, regenera energia
                if (!this.keys['ShiftLeft']) {
                    this.playerState.energy = Math.min(this.playerState.maxEnergy, this.playerState.energy + this.playerState.energyRegenRate); // Taxa de regenera√ß√£o
                }

                // Atualiza a barra de UI
                energyBar.style.width = (this.playerState.energy / this.playerState.maxEnergy) * 100 + '%';
                energyText.textContent = `ENERGIA: ${Math.floor(this.playerState.energy)}/${this.playerState.maxEnergy}`;
            }

            updateUI() {
                document.getElementById('hpFill').style.width = (this.playerState.hp / this.playerState.maxHp) * 100 + '%';
                document.getElementById('expFill').style.width = (this.playerState.exp / this.playerState.expToNext) * 100 + '%';
                document.getElementById('hpText').textContent = `HP: ${Math.ceil(this.playerState.hp)}/${this.playerState.maxHp}`;
                document.getElementById('expText').textContent = `Level ${this.playerState.level} - EXP: ${this.playerState.exp}/${this.playerState.expToNext}`;
                document.getElementById('gameStats').textContent = `Inimigos Abatidos: ${this.enemiesKilled}`;

                const timeElement = document.getElementById('survivalTime');                
                const totalSeconds = Math.floor(this.gameTime / 1000);                
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;                
                const formattedMinutes = String(minutes).padStart(2, '0');
                const formattedSeconds = String(seconds).padStart(2, '0');                
                timeElement.textContent = `Tempo Sobrevivido: ${formattedMinutes}:${formattedSeconds}`;
            }
            
            shoot() {
                if (Date.now() - this.lastShot < this.shootCooldown) return;
                this.playSound_playerShot();

                // Prepara as vari√°veis do proj√©til com base nos upgrades existentes
                let projDamage = this.playerState.baseProjectileDamage + this.predatorFocus.bonusDamage;
                let projSpeed = this.projectileSpeed;
                let projSize = this.playerState.projectileSize;
                let projClass = 'projectile';
                let projSizeMultiplier = 1;
                
                if (this.primeEffects.isMegaPropulsionActive) {
                    projDamage *= 2; 
                    projSpeed *= 2;
                    projClass = 'projectile megaprojectile';
                    projSizeMultiplier = 2; 
                }

                // Fun√ß√£o auxiliar para disparar uma salva de tiros a partir de uma origem
                const fireSalvo = (originX, originY) => {
                    const totalProjectiles = 1 + this.playerState.extraProjectiles;
                    const spreadAngle = 5 * (Math.PI / 180);
                    
                    for (let i = 0; i < totalProjectiles; i++) {
                        const dx = this.mouse.x - originX;
                        const dy = this.mouse.y - originY;
                        const baseAngle = Math.atan2(dy, dx);
                        const finalAngle = baseAngle + (i - (totalProjectiles - 1) / 2) * spreadAngle;
                        
                        const proj = {
                            x: originX, y: originY,
                            vx: Math.cos(finalAngle) * projSpeed,
                            vy: Math.sin(finalAngle) * projSpeed,
                            damage: projDamage,
                            width: projSize * projSizeMultiplier,
                            height: projSize * projSizeMultiplier,
                            element: document.createElement('div')
                        };
                        proj.element.className = projClass;
                        proj.element.style.width = proj.width + 'px';
                        proj.element.style.height = proj.height + 'px';
                        
                        this.gameObjectsContainer.appendChild(proj.element);
                        this.projectiles.push(proj);
                    }
                };

                // --- L√ìGICA PRINCIPAL DE TIRO ---
                if (this.playerState.isMecha) {
                    // MODO MECHA: Calcula a posi√ß√£o dos dois canh√µes e dispara de ambos
                    const mechaCenterX = this.playerState.x + this.playerState.width / 2;
                    const cannonY = this.playerState.y + 22; // Altura dos canh√µes
                    const cannonOffsetX = 18; // Dist√¢ncia do centro para cada canh√£o

                    fireSalvo(mechaCenterX - cannonOffsetX, cannonY); // Dispara do canh√£o esquerdo
                    fireSalvo(mechaCenterX + cannonOffsetX, cannonY); // Dispara do canh√£o direito
                } else {
                    // MODO NORMAL: Dispara do centro do jogador
                    const playerCenterX = this.playerState.x + this.playerState.width / 2;
                    const playerCenterY = this.playerState.y + this.playerState.height / 2;
                    fireSalvo(playerCenterX, playerCenterY);
                }

                this.lastShot = Date.now();
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.element.style.left = p.x + 'px';
                    p.element.style.top = p.y + 'px';
                    if (p.x < 0 || p.x > 1024 || p.y < 0 || p.y > 600) {
                        p.element.remove();
                        this.projectiles.splice(i, 1);
                    }
                }
            }

            startLevelUp() {
                this.isPaused = true;
                const screen = document.getElementById('levelUpScreen');
                const container = document.getElementById('cardContainer');
                container.innerHTML = '';

                let chosenCards;                
                if (this.playerState.level % 10 === 0) {
                    document.getElementById('levelUpTitle').textContent = 'AN√ÅLISE DE SISTEMA... UPGRADE PRIME DETECTADO!';                    
                    const primeUpgrades = this.upgrades.filter(u => u.rarity === 'PRIME');
                    chosenCards = this.selectRandomCards(3, primeUpgrades); 
                } else {
                    document.getElementById('levelUpTitle').textContent = 'Melhoria de N√≠vel! Escolha um M√≥dulo:';                    
                    const normalUpgrades = this.upgrades.filter(u => u.rarity !== 'PRIME');
                    chosenCards = this.selectRandomCards(3, normalUpgrades);
                }

                for (const card of chosenCards) {
                    const cardElement = document.createElement('div');
                    cardElement.className = `upgrade-card rarity-${card.rarity}`;
                    cardElement.innerHTML = `<div class="card-title">${card.name}</div><div class="card-rarity">${card.rarity}</div><div class="card-description">${card.description}</div>`;
                    cardElement.onclick = () => {
                        card.apply();

                        // Pega os dados do upgrade j√° coletado, ou inicia com 0 stacks
                        const currentData = this.collectedUpgrades.get(card.name) || { stacks: 0, icon: card.icon };
                        currentData.stacks++; // Incrementa o contador
                        
                        // Atualiza o Map com os novos dados
                        this.collectedUpgrades.set(card.name, currentData);
                        
                        // Chama a fun√ß√£o para redesenhar os √≠cones na tela
                        this.updateUpgradeTrackerUI();
                        
                        screen.style.display = 'none';
                        this.isPaused = false;
                        this.updateUI();
                    };
                    container.appendChild(cardElement);
                }
                screen.style.display = 'flex';
            }

            selectRandomCards(count, cardPool) {
                const sourcePool = cardPool || this.upgrades;    
                const weightedPool = [];
                for (const upgrade of sourcePool) {
                    const rarityInfo = this.rarities[upgrade.rarity];
                    for (let i = 0; i < rarityInfo.weight; i++) weightedPool.push(upgrade);
                }
                const selected = new Set();
                while (selected.size < count && selected.size < this.upgrades.length) {
                    selected.add(weightedPool[Math.floor(Math.random() * weightedPool.length)]);
                }
                return Array.from(selected);
            }

            updatePassiveEffects() {
                if (this.playerState.hpRegen > 0 && Date.now() - this.lastRegenTime > 1000) {
                    this.playerState.hp = Math.min(this.playerState.maxHp, this.playerState.hp + this.playerState.hpRegen);
                    this.lastRegenTime = Date.now();
                }
            }
            
            createExplosion(x, y, radius = 70, damage = 5, color = 'rgba(243, 156, 18, 0.7)') {
                const explosionElement = document.createElement('div');
                Object.assign(explosionElement.style, {
                    position: 'absolute', left: (x - radius) + 'px', top: (y - radius) + 'px',
                    width: (radius * 2) + 'px', height: (radius * 2) + 'px',
                    background: color, borderRadius: '50%', transform: 'scale(0)',
                    transition: 'transform 0.3s ease-out, opacity 0.3s ease-out', zIndex: '6'
                });
                this.gameObjectsContainer.appendChild(explosionElement);
                this.playSound_explosion();
                requestAnimationFrame(() => Object.assign(explosionElement.style, {transform: 'scale(1)', opacity: '0'}));
                for (const enemy of this.enemies) {
                    const dx = (enemy.x + enemy.width / 2) - x, dy = (enemy.y + enemy.height / 2) - y;
                    if (Math.sqrt(dx * dx + dy * dy) < radius) enemy.hp -= damage;
                }
                setTimeout(() => explosionElement.remove(), 300);
            }

            triggerVengeance() {
                const numProjectiles = 8;
                const pCenter = { x: this.playerState.x + 10, y: this.playerState.y + 15 };
                for (let i = 0; i < numProjectiles; i++) {
                    const angle = (i / numProjectiles) * 2 * Math.PI;
                    const p = { x: pCenter.x, y: pCenter.y, vx: Math.cos(angle) * this.projectileSpeed, vy: Math.sin(angle) * this.projectileSpeed, element: document.createElement('div') };
                    p.element.className = 'projectile';
                    this.gameObjectsContainer.appendChild(p.element);
                    this.projectiles.push(p);
                }
            }

            updatePulseEmitter() {
                if (!this.pulseEmitter.active || Date.now() - this.pulseEmitter.lastPulse <= this.pulseEmitter.cooldown) return;
                const pCenter = { x: this.playerState.x + 10, y: this.playerState.y + 15 };
                this.createExplosion(pCenter.x, pCenter.y, this.pulseEmitter.radius, this.pulseEmitter.damage, 'rgba(142, 68, 173, 0.6)');
                this.pulseEmitter.lastPulse = Date.now();
            }

            updateDrone() {
                const targetPos = { x: this.playerState.x - 20, y: this.playerState.y - 40 };
                this.droneState.x += (targetPos.x - this.droneState.x) * 0.05;
                this.droneState.y += (targetPos.y - this.droneState.y) * 0.05;

                let closestEnemy = null, minDistance = 400;
                for (const enemy of this.enemies) {
                    const dx = enemy.x - this.droneState.x, dy = enemy.y - this.droneState.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestEnemy = enemy;
                    }
                }
                this.droneState.target = closestEnemy;

                if (this.droneState.target && Date.now() - this.droneState.lastShot > this.droneState.shootCooldown) {
                    const tCenter = { x: this.droneState.target.x + 8, y: this.droneState.target.y + 8 };
                    const dx = tCenter.x - this.droneState.x, dy = tCenter.y - this.droneState.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const p = { x: this.droneState.x, y: this.droneState.y, vx: (dx / dist) * 6, vy: (dy / dist) * 6, element: document.createElement('div') };
                    p.element.className = 'drone-projectile';
                    this.gameObjectsContainer.appendChild(p.element);
                    this.droneProjectiles.push(p);
                    this.droneState.lastShot = Date.now();
                }
                this.droneElement.style.left = this.droneState.x + 'px';
                this.droneElement.style.top = this.droneState.y + 'px';
            }

            updateDroneProjectiles() {
                for (let i = this.droneProjectiles.length - 1; i >= 0; i--) {
                    const p = this.droneProjectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.element.style.left = p.x + 'px';
                    p.element.style.top = p.y + 'px';
                    if (p.x < 0 || p.x > 1024 || p.y < 0 || p.y > 600) {
                        p.element.remove();
                        this.droneProjectiles.splice(i, 1);
                        continue;
                    }
                    for (const enemy of this.enemies) {
                        if (this.checkCollision({x:p.x,y:p.y,width:4,height:4}, enemy)) {
                            enemy.hp -= 2;
                            p.element.remove();
                            this.droneProjectiles.splice(i, 1);
                            break; 
                        }
                    }
                }
            }

            updatePrimeEffects() {
                // Reseta todos os efeitos se SHIFT n√£o estiver pressionado ou n√£o houver energia
                if (!this.keys['ShiftLeft'] || this.playerState.energy <= 0) {
                    Object.keys(this.primeEffects).forEach(key => {
                        if(typeof this.primeEffects[key] === 'boolean') this.primeEffects[key] = false;
                    });
                    // Adicione aqui l√≥gicas de desativa√ß√£o, como restaurar a cor do proj√©til, etc.
                    return; 
                }

                // Se chegou aqui, SHIFT est√° pressionado e h√° energia
                this.playerState.energy -= 0.5; // Taxa de consumo de energia

                // Ativa o efeito do upgrade PRIME equipado
                switch(this.activePrimeUpgrade) {
                    case 'NITRO':
                        this.primeEffects.isNitroActive = true;
                        break;
                    case 'BLINDAGEM_MAXIMA':
                        this.primeEffects.isShieldActive = true;
                        break;
                    case 'MEGAPROPULSAO':
                        this.primeEffects.isMegaPropulsionActive = true;
                        break;
                    case 'MATRIX':
                        this.primeEffects.isMatrixActive = true;
                        break;
                    case 'BOMBARDEIO':
                        // A l√≥gica do bombardeio ser√° cont√≠nua
                        if(Date.now() - this.primeEffects.bombardment.lastBomb > this.primeEffects.bombardment.cooldown) {
                            const randomX = Math.random() * this.canvas.offsetWidth;
                            this.spawnBomb(randomX); // Nova fun√ß√£o que vamos criar
                            this.primeEffects.bombardment.lastBomb = Date.now();
                        }
                        break;
                }
            }

            spawnBomb(x) {
                const bomb = { x: x, y: -20, element: document.createElement('div') };
                bomb.element.style.cssText = 'position:absolute; width:10px; height:20px; background:red; z-index:50;';
                bomb.element.style.left = bomb.x + 'px';
                this.gameObjectsContainer.appendChild(bomb.element);
                this.bombs.push(bomb);
            }

            updateBombs() {
                for(let i = this.bombs.length - 1; i >= 0; i--) {
                    const bomb = this.bombs[i];
                    bomb.y += 8; // Velocidade da queda da bomba
                    bomb.element.style.top = bomb.y + 'px';

                    // Se a bomba atingir o ch√£o (simplificado)
                    if (bomb.y > 550) {
                        this.createExplosion(bomb.x, bomb.y, 80, 15); // Explos√£o da bomba
                        bomb.element.remove();
                        this.bombs.splice(i, 1);
                    }
                }
            }

            spawnHealingOrb(x, y) {
                const orb = {
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0, // Adicionamos velocidade vertical e horizontal
                    width: 12,
                    height: 12, // Adicionamos dimens√µes para a colis√£o
                    element: document.createElement('div')
                };
                orb.element.style.cssText = 'position:absolute; width:12px; height:12px; background:limegreen; border-radius:50%; z-index:20; box-shadow: 0 0 8px limegreen;';
                orb.element.style.left = orb.x + 'px';
                orb.element.style.top = orb.y + 'px';
                this.gameObjectsContainer.appendChild(orb.element);
                this.orbs.push(orb);
            }

            updateOrbs() {
                for (let i = this.orbs.length - 1; i >= 0; i--) {
                    const orb = this.orbs[i];

                    // --- 1. APLICAR GRAVIDADE ---
                    // Usamos uma fra√ß√£o da gravidade do jogo para uma queda mais suave.
                    orb.vy += this.gravity * 0.4;
                    orb.y += orb.vy;

                    // --- 2. VERIFICAR COLIS√ÉO COM AS PLATAFORMAS ---
                    for (const block of this.blocks) {
                        if (this.checkCollision(orb, block)) {
                            // Se o orbe estava a cair, ele para em cima do bloco.
                            if (orb.vy > 0) {
                                orb.y = block.y - orb.height; // Corrige a posi√ß√£o para ficar em cima do bloco
                                orb.vy = 0; // Para a queda
                            }
                        }
                    }

                    // --- 3. ATUALIZAR POSI√á√ÉO VISUAL ---
                    orb.element.style.top = orb.y + 'px';

                    // --- 4. VERIFICAR COLETA PELO JOGADOR (L√≥gica existente) ---
                    if (this.checkCollision(this.playerState, orb)) {
                        // Cura o jogador e limita √† vida m√°xima
                        this.playerState.hp = Math.min(this.playerState.maxHp, this.playerState.hp + 10);
                        
                        orb.element.remove();
                        this.orbs.splice(i, 1);
                    }
                }
            }

            updateStaticCharge() {
                if (!this.staticCharge.active) return;

                if (Date.now() - this.staticCharge.lastTick > this.staticCharge.cooldown) {
                    const playerCenterX = this.playerState.x + this.playerState.width / 2;
                    const playerCenterY = this.playerState.y + this.playerState.height / 2;

                    // Itera sobre os inimigos e aplica dano se estiverem no raio
                    for (const enemy of this.enemies) {
                        const dx = (enemy.x + enemy.width / 2) - playerCenterX;
                        const dy = (enemy.y + enemy.height / 2) - playerCenterY;
                        if (Math.sqrt(dx*dx + dy*dy) < this.staticCharge.radius) {
                            enemy.hp -= this.staticCharge.damage;
                            // Opcional: Adicionar um efeito visual de "zap" no inimigo
                        }
                    }
                    this.staticCharge.lastTick = Date.now();
                }
            }

            triggerDash(direction) {
                this.playerState.isDashing = true;
                this.lastDashTime = Date.now();
                this.playerState.invincible = true;

                // Impulso forte na dire√ß√£o
                this.playerState.vy = 0; // Cancela o movimento vertical para um dash mais limpo
                this.playerState.vx = 25 * direction;

                // Fim do dash e da invencibilidade ap√≥s um curto per√≠odo
                setTimeout(() => {
                    this.playerState.isDashing = false;
                    this.playerState.invincible = false;
                    // Adiciona um pequeno impulso para cima para evitar ficar preso no ch√£o
                    this.playerState.vy = -2;
                }, 150); // Dura√ß√£o do dash em ms
            }

            createTurret(side) {
                const pos = this.turretPositions[side];
                
                // Cria o corpo da torreta
                const turretElement = document.createElement('div');
                turretElement.className = 'turret';
                turretElement.style.left = pos.x + 'px';
                turretElement.style.top = pos.y + 'px';

                // Cria o cano da torreta
                const barrelElement = document.createElement('div');
                barrelElement.className = 'turret-barrel';
                turretElement.appendChild(barrelElement);

                this.gameObjectsContainer.appendChild(turretElement);

                const turret = {
                    side: side, // 'left' ou 'right'
                    x: pos.x,
                    y: pos.y,
                    width: 24,
                    height: 20,
                    damage: 1, // Dano inicial baixo
                    shootCooldown: 400, // Dispara r√°pido (a cada 0.5s)
                    lastShot: 0,
                    range: 500, // Alcance da torreta
                    element: turretElement,
                    barrelElement: barrelElement,
                };
                this.turrets.push(turret);
            }

            updateTurrets() {
                for (const turret of this.turrets) {
                    let closestEnemy = null;
                    let minDistance = turret.range;

                    // 1. Encontrar o inimigo mais pr√≥ximo dentro do alcance
                    for (const enemy of this.enemies) {
                        const distance = Math.hypot(enemy.x - turret.x, enemy.y - turret.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    }

                    if (closestEnemy) {
                        // 2. Mirar no inimigo
                        const dx = (closestEnemy.x + closestEnemy.width / 2) - (turret.x + turret.width / 2);
                        const dy = (closestEnemy.y + closestEnemy.height / 2) - (turret.y + turret.height / 2);
                        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                        turret.barrelElement.style.transform = `rotate(${angle}deg)`;

                        // 3. Atirar
                        if (Date.now() - turret.lastShot > turret.shootCooldown) {
                            this.turretShoot(turret, closestEnemy);
                            turret.lastShot = Date.now();
                        }
                    }
                }
            }

            turretShoot(turret, target) {
                const turretCenter = { x: turret.x + turret.width / 2, y: turret.y + 10 };
                const targetCenter = { x: target.x + target.width / 2, y: target.y + target.height / 2 };
                
                const dx = targetCenter.x - turretCenter.x;
                const dy = targetCenter.y - turretCenter.y;
                const dist = Math.hypot(dx, dy);

                const proj = {
                    x: turretCenter.x, y: turretCenter.y,
                    vx: (dx / dist) * 10, // Alta velocidade
                    vy: (dy / dist) * 10,
                    damage: turret.damage, // Usa o dano da torreta
                    element: document.createElement('div')
                };
                proj.element.className = 'turret-projectile';
                this.gameObjectsContainer.appendChild(proj.element);
                this.turretProjectiles.push(proj);
            }

            updateTurretProjectiles() {
                for (let i = this.turretProjectiles.length - 1; i >= 0; i--) {
                    const p = this.turretProjectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.element.style.left = p.x + 'px';
                    p.element.style.top = p.y + 'px';

                    // Remove se sair da tela
                    if (p.x < 0 || p.x > 1024 || p.y < 0 || p.y > 600) {
                        p.element.remove();
                        this.turretProjectiles.splice(i, 1);
                        continue;
                    }

                    // Verifica colis√£o com inimigos
                    for (const enemy of this.enemies) {
                        if (this.checkCollision({x:p.x,y:p.y,width:5,height:5}, enemy)) {
                            enemy.hp -= p.damage; // Aplica o dano do proj√©til
                            p.element.remove();
                            this.turretProjectiles.splice(i, 1);
                            break; 
                        }
                    }
                }
            }

            updateIonicStorm() {
                if (!this.ionicStorm.active) return;

                const now = Date.now();
                if (now - this.ionicStorm.lastStorm > this.ionicStorm.cooldown) {
                    // Chama a fun√ß√£o para criar os raios, um para cada 'numBolts'
                    for (let i = 0; i < this.ionicStorm.numBolts; i++) {
                        // Usamos um pequeno timeout para que os raios n√£o caiam todos exatamente ao mesmo tempo
                        setTimeout(() => this.triggerLightningStrike(), i * 100);
                    }
                    this.ionicStorm.lastStorm = now;
                }
            }

            triggerLightningStrike() {
                // Cria o elemento visual do raio
                const boltElement = document.createElement('div');
                boltElement.className = 'ionic-bolt';
                
                // Define uma posi√ß√£o X aleat√≥ria para o raio
                const boltX = Math.random() * this.canvas.offsetWidth;
                boltElement.style.left = boltX + 'px';
                
                this.playSound_ionicBolt();
                this.gameObjectsContainer.appendChild(boltElement);

                // Define a "hitbox" do raio
                const boltHitbox = {
                    x: boltX,
                    width: 4 // A mesma largura definida no CSS
                };

                // Verifica todos os inimigos
                for (const enemy of this.enemies) {
                    // Verifica se a hitbox horizontal do inimigo colide com a hitbox do raio
                    if (enemy.x < boltHitbox.x + boltHitbox.width && enemy.x + enemy.width > boltHitbox.x) {
                        enemy.hp -= this.ionicStorm.damage;
                    }
                }
                
                // Remove o elemento do raio ap√≥s a sua anima√ß√£o de flash terminar (200ms)
                setTimeout(() => {
                    boltElement.remove();
                }, 200);
            }

            triggerFragmentation(sourceEnemy) {
                const enemyCenter = { x: sourceEnemy.x + sourceEnemy.width / 2, y: sourceEnemy.y + sourceEnemy.height / 2 };
                const numFragments = this.fragmentationModule.numFragments;
                const fragmentSpeed = 6;

                for (let i = 0; i < numFragments; i++) {
                    // Gera um √¢ngulo aleat√≥rio para cada fragmento
                    const angle = Math.random() * 2 * Math.PI;

                    const proj = {
                        x: enemyCenter.x,
                        y: enemyCenter.y,
                        vx: Math.cos(angle) * fragmentSpeed,
                        vy: Math.sin(angle) * fragmentSpeed,
                        damage: this.fragmentationModule.damage,
                        width: 6,
                        height: 6,
                        element: document.createElement('div')
                    };
                    proj.element.className = 'fragment-projectile';
                    this.gameObjectsContainer.appendChild(proj.element);
                    this.fragmentProjectiles.push(proj);
                }
            }

            updateFragmentProjectiles() {
                for (let i = this.fragmentProjectiles.length - 1; i >= 0; i--) {
                    const p = this.fragmentProjectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.element.style.left = p.x + 'px';
                    p.element.style.top = p.y + 'px';

                    // Remove se sair da tela
                    if (p.x < 0 || p.x > 1024 || p.y < 0 || p.y > 600) {
                        p.element.remove();
                        this.fragmentProjectiles.splice(i, 1);
                        continue;
                    }

                    // Verifica colis√£o com outros inimigos
                    for (const enemy of this.enemies) {
                        if (this.checkCollision(p, enemy)) {
                            enemy.hp -= p.damage; // Aplica o dano do fragmento
                            p.element.remove();
                            this.fragmentProjectiles.splice(i, 1);
                            break; // Sai do loop de inimigos, pois o fragmento j√° atingiu um alvo
                        }
                    }
                }
            }

            updateKineticReactor() {
                if (!this.kineticReactor.active) return;

                if (this.kineticReactor.distanceMeter >= this.kineticReactor.distanceThreshold) {
                    this.launchKineticRockets();
                    // Zera o contador, mantendo o excesso de dist√¢ncia percorrida
                    this.kineticReactor.distanceMeter -= this.kineticReactor.distanceThreshold;
                }
            }

            launchKineticRockets() {
                const numRockets = this.kineticReactor.numRockets;
                for (let i = 0; i < numRockets; i++) {
                    const rocket = {
                        x: this.playerState.x + this.playerState.width / 2,
                        y: this.playerState.y,
                        vx: (Math.random() - 0.5) * 2, // Pequeno desvio lateral
                        vy: -8, // Velocidade para cima
                        width: 6, height: 14, damage: 15, radius: 50,
                        element: document.createElement('div'),
                    };
                    rocket.element.className = 'kinetic-rocket';
                    this.gameObjectsContainer.appendChild(rocket.element);
                    this.rockets.push(rocket);
                }
            }

            updateRockets() {
                for (let i = this.rockets.length - 1; i >= 0; i--) {
                    const r = this.rockets[i];
                    r.x += r.vx;
                    r.y += r.vy;
                    r.element.style.left = r.x + 'px';
                    r.element.style.top = r.y + 'px';

                    // Remove se sair do topo da tela
                    if (r.y < -20) {
                        r.element.remove();
                        this.rockets.splice(i, 1);
                        continue;
                    }

                    // Verifica colis√£o com inimigos
                    for (const enemy of this.enemies) {
                        if (this.checkCollision(r, enemy)) {
                            this.createExplosion(r.x, r.y, r.radius, r.damage);
                            r.element.remove();
                            this.rockets.splice(i, 1);
                            break; 
                        }
                    }
                }
            }

            addOrbitalSaw() {
                // Cria o elemento visual da serra
                const sawElement = document.createElement('div');
                sawElement.className = 'orbital-saw';
                this.gameObjectsContainer.appendChild(sawElement);

                // Calcula o √¢ngulo inicial para espa√ßar as serras uniformemente
                const angleStep = (2 * Math.PI) / (this.orbitalSaws.length + 1);

                const saw = {
                    element: sawElement,
                    angle: this.orbitalSaws.length * angleStep, // Define o √¢ngulo inicial
                    radius: 60, // Dist√¢ncia da √≥rbita em pixels
                    speed: 0.04, // Velocidade da √≥rbita
                    damage: 2.5,
                    width: 24,
                    height: 24,
                    lastHitTimes: new Map(), // Rastreia o √∫ltimo hit por inimigo
                };
                
                this.orbitalSaws.push(saw);

                // Reajusta o √¢ngulo de todas as serras existentes para um espa√ßamento perfeito
                this.orbitalSaws.forEach((s, index) => {
                    s.angle = index * ((2 * Math.PI) / this.orbitalSaws.length);
                });
            }

            updateOrbitalSaws() {
                if (this.orbitalSaws.length === 0) return;

                const centerX = this.playerState.x + this.playerState.width / 2;
                const centerY = this.playerState.y + this.playerState.height / 2;

                // Loop para cada serra em √≥rbita
                for (const saw of this.orbitalSaws) {
                    // 1. ATUALIZAR O MOVIMENTO ORBITAL
                    saw.angle += saw.speed; // Incrementa o √¢ngulo para girar
                    // Calcula a nova posi√ß√£o X e Y usando trigonometria
                    saw.x = centerX + saw.radius * Math.cos(saw.angle) - saw.width / 2;
                    saw.y = centerY + saw.radius * Math.sin(saw.angle) - saw.height / 2;

                    // Atualiza a posi√ß√£o do elemento HTML
                    saw.element.style.left = saw.x + 'px';
                    saw.element.style.top = saw.y + 'px';

                    // 2. VERIFICAR COLIS√ÉO E APLICAR DANO
                    for (let i = 0; i < this.enemies.length; i++) {
                        const enemy = this.enemies[i];
                        if (this.checkCollision(saw, enemy)) {
                            const lastHit = saw.lastHitTimes.get(i) || 0;
                            // S√≥ causa dano se tiver passado 0.5 segundos desde o √∫ltimo contato com ESTE inimigo
                            if (Date.now() - lastHit > 500) {
                                enemy.hp -= saw.damage;
                                saw.lastHitTimes.set(i, Date.now()); // Regista o momento do hit
                            }
                        }
                    }
                }
            }

            updateBossState() {
                // Verifica se j√° sobreviveu 10 minutos (600.000 ms) e se a batalha ainda n√£o come√ßou
                if (this.gameState === 'survival' && this.gameTime >= 600000) {
                    this.gameState = 'boss_fight';
                    this.startBossMusic();
                    this.spawnBoss();
                    document.getElementById('bossHealthBarContainer').style.display = 'block';
                }
            }
            
            spawnBoss() {
                const boss = {
                    type: 'ColmeiaMae',
                    x: (this.canvas.offsetWidth / 2) - 70, y: 60, // Posi√ß√£o central no topo
                    width: 250, height: 100,
                    hp: 2000, maxHp: 2000, // Vida muito alta
                    damageReduction: 0.50, // Blindagem robusta
                    lastSummon: Date.now(), summonCooldown: 5000, // Invoca a cada 5 segundos
                    lastShot: Date.now(), shootCooldown: 3000, // Atira a cada 3 segundos
                    element: document.createElement('div'),
                };
                boss.element.className = 'enemy colmeia-mae';
                boss.element.style.left = boss.x + 'px';
                boss.element.style.top = boss.y + 'px';

                this.gameObjectsContainer.appendChild(boss.element);
                this.boss = boss; // Guarda a refer√™ncia do chefe
            }

            triggerVictorySequence() {
                // Grande explos√£o final
                this.createExplosion(this.boss.x + this.boss.width/2, this.boss.y + this.boss.height/2, 400, 100);
                this.stopBossMusic();
                // Limpa todos os outros inimigos da tela
                this.enemies.forEach(e => e.element.remove());
                this.enemies = [];

                setTimeout(() => {
                    this.gameOver(true);
                }, 3000);
            }

            updateBoss() {
                if (!this.boss) return;

                // 1. VERIFICAR SE FOI DERROTADO
                if (this.boss.hp <= 0) {
                    this.triggerVictorySequence();
                    this.boss.element.remove();
                    this.boss = null;                    
                    document.getElementById('bossHealthBarContainer').style.display = 'none';
                    return;
                }

                // 2. ATUALIZAR BARRA DE VIDA
                document.getElementById('bossHpFill').style.width = (this.boss.hp / this.boss.maxHp) * 100 + '%';

                // 3. INVOCAR DRONES
                if (Date.now() - this.boss.lastSummon > this.boss.summonCooldown) {
                    for (let i = 0; i < 15; i++) {
                        // Sorteia entre Vigia e Vespa
                        const enemy = Math.random() < 0.7 ? this.createVigia() : this.createVespa();

                        const spawnX = this.boss.x + this.boss.width / 2;                        
                        const randomOffsetX = (Math.random() - 0.5) * 300;                        
                        enemy.x = spawnX + randomOffsetX;
                        enemy.y = this.boss.y + this.boss.height; 

                        this.gameObjectsContainer.appendChild(enemy.element);
                        this.enemies.push(enemy);
                    }
                    this.boss.lastSummon = Date.now();
                }

                // 4. ATIRAR COM O CANH√ÉO PRINCIPAL
                if (Date.now() - this.boss.lastShot > this.boss.shootCooldown) {
                    this.enemyShoot(this.boss); // Usa a fun√ß√£o de tiro padr√£o
                    this.boss.lastShot = Date.now();
                }

                // 5. VERIFICAR COLIS√ÉO COM PROJ√âTEIS DO JOGADOR
                 for (let j = this.projectiles.length - 1; j >= 0; j--) {
                    const p = this.projectiles[j];
                    if (this.checkCollision(p, this.boss)) {
                        this.boss.hp -= p.damage * (1 - this.boss.damageReduction);
                        p.element.remove();
                        this.projectiles.splice(j, 1);
                    }
                }
            }

            // --- NOVAS FUN√á√ïES DE EFEITOS SONOROS ---

            // Efeito de tiro do jogador (um "pew" r√°pido)
            playSound_playerShot() {
                if (!this.audioCtx) return;
                const oscillator = this.audioCtx.createOscillator();
                const gainNode = this.audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);

                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, this.audioCtx.currentTime); // Tom agudo
                oscillator.frequency.exponentialRampToValueAtTime(440, this.audioCtx.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.3, this.audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.1);

                oscillator.start(this.audioCtx.currentTime);
                oscillator.stop(this.audioCtx.currentTime + 0.1);
            }

            // Efeito de morte de inimigo (um "blip" grave)
            playSound_enemyDeath() {
                if (!this.audioCtx) return;
                const oscillator = this.audioCtx.createOscillator();
                const gainNode = this.audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioCtx.destination);

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(220, this.audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(55, this.audioCtx.currentTime + 0.2);

                gainNode.gain.setValueAtTime(0.2, this.audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.2);

                oscillator.start(this.audioCtx.currentTime);
                oscillator.stop(this.audioCtx.currentTime + 0.2);
            }

            // Efeito de explos√£o (ru√≠do branco simulado)
            playSound_explosion() {
                if (!this.audioCtx) return;
                const gainNode = this.audioCtx.createGain();
                gainNode.connect(this.audioCtx.destination);
                
                const bufferSize = this.audioCtx.sampleRate * 0.5; // 0.5 segundos de ru√≠do
                const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                let data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1; // Gera ru√≠do branco
                }
                const noise = this.audioCtx.createBufferSource();
                noise.buffer = buffer;
                noise.connect(gainNode);

                gainNode.gain.setValueAtTime(0.4, this.audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.4);

                noise.start(this.audioCtx.currentTime);
                noise.stop(this.audioCtx.currentTime + 0.5);
            }

            // Efeito de raio (um "zap" r√°pido e ruidoso)
            playSound_ionicBolt() {
                this.playSound_explosion(); // Reutiliza o som de explos√£o, que funciona bem para raios
            }

            // Efeito de subir de n√≠vel (notas ascendentes)
            playSound_levelUp() {
                if (!this.audioCtx) return;
                const notes = [440, 554, 659, 880]; // A, C#, E, A
                notes.forEach((freq, i) => {
                    const osc = this.audioCtx.createOscillator();
                    const gain = this.audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioCtx.destination);
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.2, this.audioCtx.currentTime + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + i * 0.1 + 0.1);
                    osc.start(this.audioCtx.currentTime + i * 0.1);
                    osc.stop(this.audioCtx.currentTime + i * 0.1 + 0.2);
                });
            }

            startBossMusic() {
                if (!this.audioCtx || this.bossMusicInterval) return;
                const notes = [110, 123, 138, 123]; // A, B, C, B (grave e tenso)
                let noteIndex = 0;
                
                this.bossMusicInterval = setInterval(() => {
                    const osc = this.audioCtx.createOscillator();
                    const gain = this.audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioCtx.destination);
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime); // Volume baixo, de fundo
                    gain.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.2);
                    osc.frequency.value = notes[noteIndex % notes.length];
                    osc.start(this.audioCtx.currentTime);
                    osc.stop(this.audioCtx.currentTime + 0.2);
                    noteIndex++;
                }, 250); // Toca uma nota a cada 250ms
            }

            stopBossMusic() {
                if (this.bossMusicInterval) {
                    clearInterval(this.bossMusicInterval);
                    this.bossMusicInterval = null;
                }
            }

            // Efeito de Game Over (notas descendentes)
            playSound_gameOver() {
                if (!this.audioCtx) return;
                const notes = [220, 164, 110, 82]; // A, E, A, E (oitavas abaixo)
                notes.forEach((freq, i) => {
                    const osc = this.audioCtx.createOscillator();
                    osc.connect(this.audioCtx.destination);
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    osc.start(this.audioCtx.currentTime + i * 0.2);
                    osc.stop(this.audioCtx.currentTime + i * 0.2 + 0.2);
                });
            }

            // Efeito de Vit√≥ria (fanfarra)
            playSound_victory() {
                this.playSound_levelUp(); // Reutiliza o som de level up, que √© positivo
            }

            gameOver(isVictory = false) {
                this.isGameOver = true; // Para o loop do jogo
                this.stopBossMusic();
                
                // --- C√ÅLCULO DA PONTUA√á√ÉO FINAL ---
                const timeScore = Math.floor(this.gameTime / 1000);
                const killsScore = this.enemiesKilled * 10;
                const levelScore = (this.playerState.level - 1) * 100;
                this.finalScore = timeScore + killsScore + levelScore; // Guarda a pontua√ß√£o na inst√¢ncia do jogo
                
                if (isVictory) {
                    this.playSound_victory();
                    document.querySelector('#gameOverScreen h2').textContent = "VIT√ìRIA!";
                    this.finalScore *= 100; // Grande b√≥nus de pontua√ß√£o
                } else {
                    this.playSound_gameOver();
                    document.querySelector('#gameOverScreen h2').textContent = "Fim de Jogo";
                }

                // --- ATUALIZAR A TELA DE GAME OVER ---
                // Preenche as estat√≠sticas na tela
                document.getElementById('levelStat').textContent = this.playerState.level;
                const totalSeconds = Math.floor(this.gameTime / 1000);
                const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
                const seconds = String(totalSeconds % 60).padStart(2, '0');
                document.getElementById('timeStat').textContent = `${minutes}:${seconds}`;
                document.getElementById('killsStat').textContent = this.enemiesKilled;
                document.getElementById('scoreStat').textContent = this.finalScore;

                // Mostra a se√ß√£o para salvar o score e o campo de nome
                document.getElementById('saveScoreSection').style.display = 'block';
                document.getElementById('playerNameInput').value = '';

                // Mostra a tela de Game Over
                showScreen('gameOverScreen');
            }

            gameLoop() {
                if (this.isGameOver) return;
                if (this.isPaused) {
                    requestAnimationFrame(() => this.gameLoop());
                    return;
                }
                
                this.gameTime += 16;
                
                if (this.playerState.invincible && Date.now() - this.playerState.invincibleTime > this.invincibilityDuration) {
                    this.playerState.invincible = false;
                    this.player.classList.remove('invincible');
                }
                
                this.updatePlayer();
                this.spawnEnemy();
                this.updateEnemies();
                this.updateBossState();
                this.updateBoss();
                this.updatePrimeEffects();
                this.updatePassiveEffects();
                this.updatePulseEmitter();
                this.updateBombs();
                this.updateOrbs();
                this.updateStaticCharge();
                this.updateTurrets();
                this.updateTurretProjectiles();
                this.updateIonicStorm();
                this.updateFragmentProjectiles();
                this.updateKineticReactor();
                this.updateRockets(); 
                this.updateEnergyShield();
                this.updateOrbitalSaws();
                this.updateFallingBombs();


                if (this.droneState.active) this.updateDrone();
                
                if (this.mouse.pressed) this.shoot();
                
                this.updateProjectiles();
                this.updateEnemyProjectiles();
                this.updateDroneProjectiles();
                this.updateEnergy();
                this.updateUI();
                
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // --- NOVO SISTEMA DE RECORDES ---
        function getHighScores() {
            const scoresJSON = localStorage.getItem('robotHighScores');
            // Se n√£o houver scores, retorna um array vazio. Sen√£o, converte de texto para objeto.
            return scoresJSON ? JSON.parse(scoresJSON) : [];
        }

        function addHighScore(name, score) {
            const scores = getHighScores();
            scores.push({ name, score });
            // Ordena os scores do maior para o menor
            scores.sort((a, b) => b.score - a.score);
            // Salva apenas os 10 melhores
            const top10 = scores.slice(0, 10);
            // Converte para texto e salva no localStorage
            localStorage.setItem('robotHighScores', JSON.stringify(top10));
        }

        function displayHighScores() {
            const scores = getHighScores();
            const listElement = document.getElementById('highScoresList');
            listElement.innerHTML = ''; // Limpa a lista antiga

            if (scores.length === 0) {
                listElement.innerHTML = '<li>Ainda n√£o h√° recordes. Seja o primeiro!</li>';
            } else {
                scores.forEach(s => {
                    const li = document.createElement('li');
                    li.textContent = `${s.name} - ${s.score} pontos`;
                    listElement.appendChild(li);
                });
            }
            showScreen('highScoresScreen');
        }

        // --- NOVO SISTEMA DE INICIALIZA√á√ÉO E GERENCIAMENTO DE TELAS ---
        let audioCtx; // Vari√°vel global para o nosso AudioContext
        let currentGame; // Vari√°vel para guardar a inst√¢ncia do jogo atual

        // Fun√ß√£o para mostrar uma tela e esconder as outras
        function showScreen(screenId) {
            document.querySelectorAll('.screen, #gameCanvas').forEach(el => {
                el.style.display = 'none';
            });
            document.getElementById(screenId).style.display = 'flex';
        }

        function displayAboutScreen() {
            showScreen('aboutScreen');
        }

        function populateAboutScreen() {
            const contentContainer = document.getElementById('aboutContent');
            const gameInfoHTML = `
                <h1>Sobre o Robot's Last Stand</h1>
                <p>Num futuro n√£o muito distante, uma Intelig√™ncia Artificial de defesa global, a "Tit√£", tornou-se desonesta. Originalmente criada para proteger, ela agora v√™ a humanidade como a principal amea√ßa ao planeta. A Tit√£ tomou o controlo de todas as f√°bricas automatizadas, criando um ex√©rcito infinito de drones de combate com um √∫nico objetivo: apagar os seus criadores.</p>
                <p>A resist√™ncia foi esmagada. As cidades ca√≠ram. Apenas uma esperan√ßa resta: a Unidade 734, um prot√≥tipo de combate avan√ßado que voc√™ controla. O seu rob√¥ √© especial. Ele possui um reator de assimila√ß√£o √∫nico, capaz de analisar os destro√ßos dos inimigos e reconfigurar os seus pr√≥prios sistemas em tempo real, tornando-se mais forte e mais letal a cada abate.</p>
                <p>Esta √© a √∫ltima defesa. Voc√™ √© a √∫ltima esperan√ßa.</p>
                
                <h3>Como Jogar</h3>
                <ul>
                    <li><strong>Movimento:</strong> Teclas A/D ou Setas Esquerda/Direita.</li>
                    <li><strong>Pulo:</strong> Barra de Espa√ßo, W ou Seta para Cima.</li>
                    <li><strong>Mirar:</strong> Mova o Mouse para apontar.</li>
                    <li><strong>Atirar:</strong> Clique Esquerdo do Mouse.</li>
                    <li><strong>Habilidades PRIME:</strong> Segure SHIFT para ativar.</li>
                </ul>

                <h3>Wiki de Inimigos</h3>
                <ul>
                    <li><strong>Vigia:</strong> Infantaria b√°sica que ataca em enxames.</li>
                    <li><strong>Vespa:</strong> Perseguidor r√°pido de curto alcance.</li>
                    <li><strong>Ariete:</strong> Ataca em linha reta para causar dano de colis√£o.</li>
                    <li><strong>Unidade Inst√°vel:</strong> Kamikaze que explode perto do jogador.</li>
                    <li><strong>Bombardeiro:</strong> Larga bombas do topo da tela.</li>
                    <li><strong>Basti√£o:</strong> Tanque lento com vida muito alta.</li>
                    <li><strong>Ceifador:</strong> Sniper de longo alcance com mira a laser.</li>
                    <li><strong>Drone M√©dico:</strong> Unidade de suporte que cura e protege outros drones.</li>
                    <li><strong>Colmeia-M√£e (CHEFE):</strong> Aparece aos 10 minutos. Invoca enxames de inimigos.</li>
                </ul>

                <h3>Wiki de Upgrades</h3>
                <p>Colete m√≥dulos para melhorar o seu rob√¥. As cores indicam a raridade: <strong>Comum (Branco)</strong>, <strong>Incomum (Verde)</strong>, <strong>Raro (Azul)</strong>, <strong>√âpico (Roxo)</strong>, <strong>Lend√°rio (Dourado)</strong> e <strong>PRIME (Ciano)</strong>.</p>
                
                <hr>
                <p style="text-align:center; font-style:italic;">Um jogo criado por: Rafael "Ramestre" dos Santos (@rafael.s.rafael)</p>
                `;
            // Adiciona o bot√£o de voltar no final
            contentContainer.innerHTML = gameInfoHTML;
        }

        // Fun√ß√£o para iniciar uma nova partida
        function startGame() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            const gameObjectsContainer = document.getElementById('gameObjectsContainer');
            if (gameObjectsContainer) {                
                gameObjectsContainer.innerHTML = '';
            }
            const trackerContainer = document.getElementById('upgradeTracker');
            trackerContainer.innerHTML = '';            

            showScreen('gameCanvas');
            currentGame = new Game(audioCtx);
        }

        // Quando a p√°gina carregar, mostra o menu principal
        window.addEventListener('load', () => {
            // Liga os bot√µes do menu √†s suas fun√ß√µes
            document.getElementById('startGameBtn').onclick = startGame;
            document.getElementById('trophyBtn').onclick = displayHighScores;
            document.getElementById('playAgainBtn').onclick = startGame;
            document.getElementById('backToMenuBtn').onclick = () => showScreen('mainMenu');
            document.getElementById('backToMenuFromScoresBtn').onclick = () => showScreen('mainMenu');
            document.getElementById('helpBtn').onclick = displayAboutScreen;
            document.getElementById('backToMenuFromAboutBtn').onclick = () => showScreen('mainMenu');
            document.getElementById('saveScoreBtn').onclick = () => {
                const playerName = document.getElementById('playerNameInput').value.toUpperCase();
                if (playerName && currentGame) {
                    addHighScore(playerName, currentGame.finalScore);
                    document.getElementById('saveScoreSection').style.display = 'none'; // Esconde o campo ap√≥s salvar
                }
            };

            populateAboutScreen();
            
            showScreen('mainMenu'); // Mostra o menu inicial
        });
    </script>
</body>
</html>